<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"    
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt">

<!-- (c) 2008, Trimble Navigation Limited. All rights reserved.                                -->
<!-- Permission is hereby granted to use, copy, modify, or distribute this style sheet for any -->
<!-- purpose and without fee, provided that the above copyright notice appears in all copies   -->
<!-- and that both the copyright notice and the limited warranty and restricted rights notice  -->
<!-- below appear in all supporting documentation.                                             -->

<!-- TRIMBLE NAVIGATION LIMITED PROVIDES THIS STYLE SHEET "AS IS" AND WITH ALL FAULTS.         -->
<!-- TRIMBLE NAVIGATION LIMITED SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY -->
<!-- OR FITNESS FOR A PARTICULAR USE. TRIMBLE NAVIGATION LIMITED DOES NOT WARRANT THAT THE     -->
<!-- OPERATION OF THIS STYLE SHEET WILL BE UNINTERRUPTED OR ERROR FREE.                        -->

<xsl:output method="html" omit-xml-declaration="no"  encoding="utf-8"/>

<!-- Set the numeric display details i.e. decimal point, thousands separator etc -->
<xsl:variable name="DecPt" select="'.'"/>    <!-- Change as appropriate for US/European -->
<xsl:variable name="GroupSep" select="','"/> <!-- Change as appropriate for US/European -->
<!-- Also change decimal-separator & grouping-separator in decimal-format below 
     as appropriate for US/European output -->
<xsl:decimal-format name="Standard" 
                    decimal-separator="."
                    grouping-separator=","
                    infinity="Infinity"
                    minus-sign="-"
                    NaN="?"
                    percent="%"
                    per-mille="&#2030;"
                    zero-digit="0" 
                    digit="#" 
                    pattern-separator=";" />

<xsl:variable name="DecPl0" select="'#0'"/>
<xsl:variable name="DecPl1" select="concat('#0', $DecPt, '0')"/>
<xsl:variable name="DecPl2" select="concat('#0', $DecPt, '00')"/>
<xsl:variable name="DecPl3" select="concat('#0', $DecPt, '000')"/>
<xsl:variable name="DecPl4" select="concat('#0', $DecPt, '0000')"/>
<xsl:variable name="DecPl5" select="concat('#0', $DecPt, '00000')"/>
<xsl:variable name="DecPl6" select="concat('#0', $DecPt, '000000')"/>
<xsl:variable name="DecPl8" select="concat('#0', $DecPt, '00000000')"/>

<xsl:variable name="Pi" select="3.14159265358979323846264"/>
<xsl:variable name="halfPi" select="$Pi div 2.0"/>
<xsl:variable name="DegreesSymbol" select="'&#0176;'"/>
<xsl:variable name="MinutesSymbol"><xsl:text>'</xsl:text></xsl:variable>
<xsl:variable name="SecondsSymbol" select="'&quot;'"/>

<xsl:variable name="fileExt" select="'htm'"/>

<xsl:key name="reducedPt-search" match="/JOBFile/Reductions/Point" use="Name"/>

<!-- User variable definitions - Appropriate fields are displayed on the       -->
<!-- Survey Controller screen to allow the user to enter specific values       -->
<!-- which can then be used within the style sheet definition to control the   -->
<!-- output data.                                                              -->
<!--                                                                           -->
<!-- All user variables must be identified by a variable element definition    -->
<!-- named starting with 'userField' (case sensitive) followed by one or more  -->
<!-- characters uniquely identifying the user variable definition.             -->
<!--                                                                           -->
<!-- The text within the 'select' field for the user variable description      -->
<!-- references the actual user variable and uses the '|' character to         -->
<!-- separate the definition details into separate fields as follows:          -->
<!-- For all user variables the first field must be the name of the user       -->
<!-- variable itself (this is case sensitive) and the second field is the      -->
<!-- prompt that will appear on the Survey Controller screen.                  -->
<!-- The third field defines the variable type - there are four possible       -->
<!-- variable types: Double, Integer, String and StringMenu.  These variable   -->
<!-- type references are not case sensitive.                                   -->
<!-- The fields that follow the variable type change according to the type of  -->
<!-- variable as follow:                                                       -->
<!-- Double and Integer: Fourth field = optional minimum value                 -->
<!--                     Fifth field = optional maximum value                  -->
<!--   These minimum and maximum values are used by the Survey Controller for  -->
<!--   entry validation.                                                       -->
<!-- String: No further fields are needed or used.                             -->
<!-- StringMenu: Fourth field = number of menu items                           -->
<!--             Remaining fields are the actual menu items - the number of    -->
<!--             items provided must equal the specified number of menu items. -->
<!--                                                                           -->
<!-- The style sheet must also define the variable itself, named according to  -->
<!-- the definition.  The value within the 'select' field will be displayed in -->
<!-- the Survey Controller as the default value for the item.                  -->


<!-- **************************************************************** -->
<!-- Set global variables from the Environment section of JobXML file -->
<!-- **************************************************************** -->
<xsl:variable name="DistUnit"   select="/JOBFile/Environment/DisplaySettings/DistanceUnits" />
<xsl:variable name="AngleUnit"  select="/JOBFile/Environment/DisplaySettings/AngleUnits" />
<xsl:variable name="CoordOrder" select="/JOBFile/Environment/DisplaySettings/CoordinateOrder" />
<xsl:variable name="TempUnit"   select="/JOBFile/Environment/DisplaySettings/TemperatureUnits" />
<xsl:variable name="PressUnit"  select="/JOBFile/Environment/DisplaySettings/PressureUnits" />
<xsl:variable name="AreaUnit"   select="/JOBFile/Environment/DisplaySettings/AreaUnits" />

<!-- Setup conversion factor for coordinate and distance values -->
<!-- Dist/coord values in JobXML file are always in metres -->
<xsl:variable name="DistConvFactor">
  <xsl:choose>
    <xsl:when test="$DistUnit='Metres'">1.0</xsl:when>
    <xsl:when test="$DistUnit='InternationalFeet'">3.280839895</xsl:when>
    <xsl:when test="$DistUnit='USSurveyFeet'">3.2808333333357</xsl:when>
    <xsl:otherwise>1.0</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<!-- Setup conversion factor for angular values -->
<!-- Angular values in JobXML file are always in decimal degrees -->
<xsl:variable name="AngleConvFactor">
  <xsl:choose>
    <xsl:when test="$AngleUnit='DMSDegrees'">1.0</xsl:when>
    <xsl:when test="$AngleUnit='Gons'">1.111111111111</xsl:when>
    <xsl:when test="$AngleUnit='Mils'">17.77777777777</xsl:when>
    <xsl:otherwise>1.0</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<!-- Setup conversion factor for area values -->
<xsl:variable name="AreaConvFactor">
  <xsl:choose>
    <xsl:when test="$AreaUnit = 'SquareMetres'">1.0</xsl:when>
    <xsl:when test="$AreaUnit = 'SquareMiles'">
      <xsl:value-of select="1.0 div 2589988.110336"/>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'SquareFeet'">
      <xsl:value-of select="3.280839895 * 3.280839895"/>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'SquareUSSurveyFeet'">
      <xsl:value-of select="3.2808333333357 * 3.2808333333357"/>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'Acres'">
      <xsl:value-of select="1.0 div 4046.8564224"/>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'Hectares'">0.0001</xsl:when>
    <xsl:otherwise>1.0</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<!-- Setup boolean variable for coordinate order -->
<xsl:variable name="NECoords">
  <xsl:choose>
    <xsl:when test="$CoordOrder='North-East-Elevation'">true</xsl:when>
    <xsl:when test="$CoordOrder='X-Y-Z'">true</xsl:when>
    <xsl:otherwise>false</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<!-- Setup conversion factor for pressure values -->
<!-- Pressure values in JobXML file are always in millibars (hPa) -->
<xsl:variable name="PressConvFactor">
  <xsl:choose>
    <xsl:when test="$PressUnit='MilliBar'">1.0</xsl:when>
    <xsl:when test="$PressUnit='InchHg'">0.029529921</xsl:when>
    <xsl:when test="$PressUnit='mmHg'">0.75006</xsl:when>
    <xsl:otherwise>1.0</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<xsl:variable name="azimuthFormat" select="/JOBFile/Environment/DisplaySettings/AzimuthFormat"/>

<xsl:variable name="product">
  <xsl:choose>
    <xsl:when test="JOBFile/@product"><xsl:value-of select="JOBFile/@product"/></xsl:when>
    <xsl:otherwise>Trimble Survey Controller</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<xsl:variable name="version">
  <xsl:choose>
    <xsl:when test="JOBFile/@productVersion"><xsl:value-of select="JOBFile/@productVersion"/></xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="format-number(JOBFile/@version div 100, $DecPl2, 'Standard')"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<xsl:variable name="reducedPoints">
  <xsl:copy-of select="/JOBFile/Reductions/*"/>
</xsl:variable>

<xsl:variable name="arcRecords">
  <xsl:copy-of select="/JOBFile/FieldBook/ArcRecord"/>
</xsl:variable>

<xsl:variable name="lineRecords">
  <xsl:copy-of select="/JOBFile/FieldBook/LineRecord"/>
</xsl:variable>

<!-- **************************************************************** -->
<!-- ************************** Main Loop *************************** -->
<!-- **************************************************************** -->
<xsl:template match="/" >
  <html>
  <font face="Arial">

  <title>Area Computation Report</title>
  <h2>Area Computation Report</h2>

  <!-- Set the font size for use in tables -->
  <style type="text/css">
    body, table, td, th
    {
      font-size:13px;
    }
  </style>

  <head>
  </head>

  <body>
  <table border="0" width="100%" cellpadding="5">
    <tr>
      <td align="left" width="30%">Job name:</td>
      <td align="left" width="20%"><xsl:value-of select="JOBFile/@jobName"/></td>
      <td align="left" width="30%"><xsl:value-of select="$product"/> version:</td>
      <td align="left" width="20%"><xsl:value-of select="$version"/></td>
    </tr>
    <tr>
      <td align="left" width="30%">Job creation date:</td>
      <td align="left" width="20%">
        <xsl:call-template name="formattedDate">
          <xsl:with-param name="timeStamp" select="JOBFile/@TimeStamp"/>
        </xsl:call-template>
      </td>
    </tr>
  </table>

  <xsl:if test="(JOBFile/FieldBook/JobPropertiesRecord[last()]/Reference != '') or
                (JOBFile/FieldBook/JobPropertiesRecord[last()]/Description != '')">
    <table border="0" width="100%" cellpadding="5">
      <tr>
        <td align="left" width="30%">Job reference:</td>
        <td align="left" width="70%"><xsl:value-of select="JOBFile/FieldBook/JobPropertiesRecord[last()]/Reference"/></td>
      </tr>
      <tr>
        <td align="left" width="30%">Job description:</td>
        <td align="left" width="70%"><xsl:value-of select="JOBFile/FieldBook/JobPropertiesRecord[last()]/Description"/></td>
      </tr>
    </table>
  </xsl:if>

  <xsl:call-template name="separatingLine"/>

  <!-- Select the FieldBook node to process -->
  <xsl:apply-templates select="JOBFile/FieldBook" />

  </body>
  </font>
  </html>
</xsl:template>


<!-- **************************************************************** -->
<!-- ***************** FieldBook Node Processing ******************** -->
<!-- **************************************************************** -->
<xsl:template match="FieldBook">

  <xsl:for-each select="*[(name(.) = 'ComputeAreaRecord') or (name(.) = 'SubdivideAreaRecord')]">

    <!-- Output a table showing the area details (area and perimeter) -->
    <xsl:call-template name="outputAreaDetails">
      <xsl:with-param name="caption">
        <xsl:choose>
          <xsl:when test="name(.) = 'ComputeAreaRecord'">
            <xsl:text>Computed area: </xsl:text>
            <xsl:value-of select="Name"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>Subdivided area: </xsl:text>
            <xsl:value-of select="Name"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:with-param>
      <xsl:with-param name="captionFontSize">4</xsl:with-param>
      <xsl:with-param name="detailsToOutput">completeFigure</xsl:with-param>
    </xsl:call-template>

    <!-- Output a table showing the figure perimeter element dimensions -->
    <xsl:for-each select="ListOfEntities">
      <xsl:call-template name="outputAreaEntities">
        <xsl:with-param name="caption">
          <xsl:choose>
            <xsl:when test="name(.) = 'SubdivideAreaRecord'">Original Boundary Elements</xsl:when>
            <xsl:otherwise>Boundary Elements</xsl:otherwise>
          </xsl:choose>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:for-each>

    <xsl:if test="name(.) = 'SubdivideAreaRecord'">  <!-- Add extra details relating to the subdivided area -->
      <xsl:if test="count(CreatedPoints/Item) != 0">
        <xsl:call-template name="OutputNewPointsTable"/>
      </xsl:if>

      <!-- Output a table showing the subdivided area details (area and perimeter) -->
      <xsl:call-template name="outputAreaDetails">
        <xsl:with-param name="caption">Subdivided Figure</xsl:with-param>
        <xsl:with-param name="detailsToOutput">subdividedFigure</xsl:with-param>
      </xsl:call-template>

      <!-- Output a table showing the subdivided figure perimeter element dimensions -->
      <xsl:for-each select="ListOfSubEntities">
        <xsl:call-template name="outputAreaEntities">
          <xsl:with-param name="caption">Subdivided Figure Boundary Elements</xsl:with-param>
        </xsl:call-template>
      </xsl:for-each>

      <!-- Get the length of the subdividing line so it can be included in the balance figure perimeter length -->
      <xsl:variable name="subdividingLineLength">
        <xsl:call-template name="LengthOfSubdividingLine"/>
      </xsl:variable>

      <!-- Output a table showing the balance area details (area and perimeter) -->
      <xsl:call-template name="outputAreaDetails">
        <xsl:with-param name="caption">Balance Figure</xsl:with-param>
        <xsl:with-param name="detailsToOutput">balanceFigure</xsl:with-param>
        <xsl:with-param name="subdividingLineLength" select="$subdividingLineLength"/>
      </xsl:call-template>

      <xsl:call-template name="outputBalanceFigureEntities">
        <xsl:with-param name="caption">Balance Figure Boundary Elements</xsl:with-param>
      </xsl:call-template>
    </xsl:if>

    <xsl:call-template name="blankLine"/>
    <xsl:call-template name="blankLine"/>
  </xsl:for-each>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************* Write the area details out to a table ************ -->
<!-- **************************************************************** -->
<xsl:template name="outputAreaDetails">
  <xsl:param name="caption"/>
  <xsl:param name="detailsToOutput" select="'completeFigure'"/>
  <xsl:param name="subdividingLineLength" select="0"/>
  <xsl:param name="captionFontSize" select="2"/>

  <xsl:call-template name="startTable">
    <xsl:with-param name="caption" select="$caption"/>
    <xsl:with-param name="captionFontSize" select="$captionFontSize"/>
  </xsl:call-template>

    <tr>
      <th align="left" bgcolor="silver" width="30%">Details</th>
      <th align="left" bgcolor="silver" width="70%">&#160;</th>
    </tr>
    <tr>
      <td align="left" width="30%">
        <xsl:choose>
          <xsl:when test="name(.) = 'ComputeAreaRecord'">Area</xsl:when>
          <xsl:otherwise>
            <xsl:choose>
              <xsl:when test="$detailsToOutput = 'completeFigure'">Original Figure Area</xsl:when>
              <xsl:when test="$detailsToOutput = 'subdividedFigure'">Subdivided Area</xsl:when>
              <xsl:otherwise>Balance Area</xsl:otherwise>
            </xsl:choose>
          </xsl:otherwise>
        </xsl:choose>
      </td>
      <td align="left" width="70%">
        <xsl:call-template name="areaValueString">
          <xsl:with-param name="area">
            <xsl:choose>
              <xsl:when test="$detailsToOutput = 'completeFigure'">
                <xsl:value-of select="Area"/>
              </xsl:when>
              <xsl:when test="$detailsToOutput = 'subdividedFigure'">
                <xsl:value-of select="SubArea"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="Area - SubArea"/>  <!-- Area of balance -->
              </xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>
      </td>
    </tr>
    <tr>
      <td align="left" width="30%">
        <xsl:choose>
          <xsl:when test="name(.) = 'ComputeAreaRecord'">Perimeter Length</xsl:when>
          <xsl:otherwise>
            <xsl:choose>
              <xsl:when test="$detailsToOutput = 'completeFigure'">Original Perimeter Length</xsl:when>
              <xsl:when test="$detailsToOutput = 'subdividedFigure'">Subdivided Figure Perimeter Length</xsl:when>
              <xsl:otherwise>Balance Figure Perimeter Length</xsl:otherwise>
            </xsl:choose>
          </xsl:otherwise>
        </xsl:choose>
      </td>
      <td align="left" width="70%">
        <xsl:call-template name="distValueString">
          <xsl:with-param name="distance">
            <xsl:choose>
              <xsl:when test="$detailsToOutput = 'completeFigure'">
                <xsl:value-of select="Perimeter"/>
              </xsl:when>
              <xsl:when test="$detailsToOutput = 'subdividedFigure'">
                <xsl:value-of select="SubPerimeter"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="Perimeter - SubPerimeter + 2.0 * $subdividingLineLength"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:with-param>
        </xsl:call-template>
      </td>
    </tr>
  <xsl:call-template name="endTable"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ******* Write the area perimeter entities out to a table ******* -->
<!-- **************************************************************** -->
<xsl:template name="outputAreaEntities">
  <xsl:param name="caption"/>

  <xsl:call-template name="startTable">
    <xsl:with-param name="caption" select="$caption"/>
  </xsl:call-template>
    <tr>
      <th align="center" bgcolor="silver" width="12%">Type</th>
      <th align="center" bgcolor="silver" width="17%">Start Pt</th>
      <th align="center" bgcolor="silver" width="17%">End Pt</th>
      <th align="center" bgcolor="silver" width="18%">Azimuth</th>
      <th align="center" bgcolor="silver" width="18%">Arc Angle</th>
      <th align="center" bgcolor="silver" width="18%">Length (grid)</th>
    </tr>
    <xsl:for-each select="Entity">
      <tr>
        <td align="left" width="12%">     <!-- Entity type Line/Arc -->
          <xsl:value-of select="Type"/>
        </td>
        <td align="left" width="17%">     <!-- Entity start point name -->
          <xsl:call-template name="GetEntityStartPointName"/>
        </td>
        <td align="left" width="17%">     <!-- Entity end point name -->
          <xsl:call-template name="GetEntityEndPointName"/>
        </td>
        <td align="right" width="18%">   <!-- Output line azimuth -->
          <xsl:choose>
            <xsl:when test="Type = 'Line'">
              <xsl:call-template name="FormatAzimuth">
                <xsl:with-param name="TheAzimuth">
                  <xsl:call-template name="InverseAzimuth">
                    <xsl:with-param name="deltaN" select="End/North - Start/North"/>
                    <xsl:with-param name="deltaE" select="End/East - Start/East"/>
                  </xsl:call-template>
                </xsl:with-param>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>&#160;</xsl:otherwise>
          </xsl:choose>
        </td>
        <td align="right" width="18%">   <!-- Output arc angle -->
          <xsl:choose>
            <xsl:when test="Type = 'Line'">&#160;</xsl:when>
            <xsl:otherwise>
              <xsl:variable name="dirn">
                <xsl:choose>
                  <xsl:when test="Direction = 'Right'">1</xsl:when>
                  <xsl:otherwise>-1</xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:call-template name="FormatAngle">
                <xsl:with-param name="TheAngle" select="ScribedAngle * $dirn"/>
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
        </td>
        <td align="right" width="18%">      <!-- Entity line or arc length -->
          <xsl:choose>
            <xsl:when test="Type = 'Line'">
              <xsl:call-template name="distValueString">
                <xsl:with-param name="distance">
                  <xsl:call-template name="InverseDistance">
                    <xsl:with-param name="deltaN" select="End/North - Start/North"/>
                    <xsl:with-param name="deltaE" select="End/East - Start/East"/>
                  </xsl:call-template>
                </xsl:with-param>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:choose>
                <xsl:when test="radius">
                  <xsl:call-template name="distValueString">
                    <xsl:with-param name="distance" select="ScribedAngle * $Pi div 180.0 * radius"/>
                  </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="arcName" select="Name"/>
                  <xsl:variable name="radius">
                    <!-- Attempt to get radius from ArcElement -->
                    <xsl:variable name="radFromElement" select="msxsl:node-set($arcRecords)/*[Name = $arcName]/Radius"/>
                    <xsl:choose>
                      <xsl:when test="string(number($radFromElement)) != 'NaN'">
                        <xsl:value-of select="$radFromElement"/>
                      </xsl:when>
                      <xsl:otherwise>  <!-- Compute radius using centre coordinates -->
                        <xsl:call-template name="InverseDistance">
                          <xsl:with-param name="deltaN" select="Start/North - Center/North"/>
                          <xsl:with-param name="deltaE" select="Start/East - Center/East"/>
                        </xsl:call-template>
                      </xsl:otherwise>
                    </xsl:choose>
                  </xsl:variable>
                  <xsl:call-template name="distValueString">
                    <xsl:with-param name="distance" select="ScribedAngle * $Pi div 180.0 * $radius"/>
                  </xsl:call-template>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </td>
      </tr>
    </xsl:for-each>
  <xsl:call-template name="endTable"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************** Return the entity start point name ************** -->
<!-- **************************************************************** -->
<xsl:template name="GetEntityStartPointName">

  <xsl:choose>
    <xsl:when test="Type = 'Arc'">  <!-- Arc element -->
      <xsl:choose>
        <xsl:when test="Start/Name != ''">
          <xsl:value-of select="Start/Name"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="ArcPointName">
            <xsl:with-param name="arcName" select="Name"/>
            <xsl:with-param name="posn">
              <xsl:copy-of select="Start/*"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:otherwise>  <!-- Line element -->
      <xsl:choose>
        <xsl:when test="Start/Name != ''">   <!-- There is a start name available -->
          <xsl:value-of select="Start/Name"/>
        </xsl:when>

        <xsl:otherwise>  <!-- No start name -->
          <xsl:choose>
            <xsl:when test="Name != ''">  <!-- There is a job line name or background file element name specified -->
              <xsl:call-template name="linePointName">
                <xsl:with-param name="lineName" select="Name"/>
                <xsl:with-param name="posn">
                  <xsl:copy-of select="Start/*"/>
                </xsl:with-param>
              </xsl:call-template>
            </xsl:when>
            
            <xsl:otherwise>  <!-- There is no Name specified - must be a point -->
              <xsl:choose>
                <xsl:when test="preceding-sibling::Entity[1]/Type = 'Arc'">  <!-- Get the preceding arc's end point name -->
                  <xsl:choose>
                    <xsl:when test="preceding-sibling::Entity[1]/End/Name != ''">
                      <xsl:value-of select="preceding-sibling::Entity[1]/End/Name"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:call-template name="ArcPointName">
                        <xsl:with-param name="arcName" select="preceding-sibling::Entity[1]/Name"/>
                        <xsl:with-param name="startPoint" select="'false'"/>
                        <xsl:with-param name="posn">
                          <xsl:copy-of select="preceding-sibling::Entity[1]/End/*"/>
                        </xsl:with-param>
                      </xsl:call-template>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:when>
                
                <xsl:otherwise>
                  <!-- Check if there is a point in the Reductions section matching this position -->
                  <xsl:variable name="matchedPtName">
                    <xsl:call-template name="NameFromReductionsPointMatch">
                      <xsl:with-param name="posn" select="Start"/>
                    </xsl:call-template>
                  </xsl:variable>
                  <xsl:choose>
                    <xsl:when test="$matchedPtName != ''">
                      <xsl:value-of select="$matchedPtName"/>
                    </xsl:when>
                    <xsl:otherwise>N/A</xsl:otherwise>  <!-- No name available -->
                  </xsl:choose>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- *************** Return the entity end point name *************** -->
<!-- **************************************************************** -->
<xsl:template name="GetEntityEndPointName">

  <xsl:choose>
    <xsl:when test="Type = 'Arc'">  <!-- Arc element -->
      <xsl:choose>
        <xsl:when test="End/Name != ''">
          <xsl:value-of select="End/Name"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="ArcPointName">
            <xsl:with-param name="arcName" select="Name"/>
            <xsl:with-param name="startPoint" select="'false'"/>
            <xsl:with-param name="posn">
              <xsl:copy-of select="End/*"/>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <xsl:otherwise>  <!-- Line element -->
      <xsl:choose>
        <xsl:when test="End/Name != ''">   <!-- There is an end name available -->
          <xsl:value-of select="End/Name"/>
        </xsl:when>

        <xsl:otherwise>  <!-- No end name -->
          <xsl:choose>
            <xsl:when test="Name != ''">  <!-- There is a job line name or background file element name specified -->
              <xsl:call-template name="linePointName">
                <xsl:with-param name="lineName" select="Name"/>
                <xsl:with-param name="startPoint" select="'false'"/>
                <xsl:with-param name="posn">
                  <xsl:copy-of select="End/*"/>
                </xsl:with-param>
              </xsl:call-template>
            </xsl:when>

            <xsl:otherwise>  <!-- There is no Name specified - must be a point -->
              <xsl:choose>
                <xsl:when test="following-sibling::Entity[1]/Type = 'Arc'">  <!-- Get the following arc's start point name -->
                  <xsl:choose>
                    <xsl:when test="following-sibling::Entity[1]/Start/Name != ''">
                      <xsl:value-of select="following-sibling::Entity[1]/Start/Name"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:call-template name="ArcPointName">
                        <xsl:with-param name="arcName" select="following-sibling::Entity[1]/Name"/>
                        <xsl:with-param name="posn">
                          <xsl:copy-of select="following-sibling::Entity[1]/Start/*"/>
                        </xsl:with-param>
                      </xsl:call-template>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:when>

                <xsl:otherwise>
                  <!-- Check if there is a point in the Reductions section matching this position -->
                  <xsl:variable name="matchedPtName">
                    <xsl:call-template name="NameFromReductionsPointMatch">
                      <xsl:with-param name="posn" select="End"/>
                    </xsl:call-template>
                  </xsl:variable>
                  <xsl:choose>
                    <xsl:when test="$matchedPtName != ''">
                      <xsl:value-of select="$matchedPtName"/>
                    </xsl:when>
                    <xsl:otherwise>N/A</xsl:otherwise>  <!-- No name available -->
                  </xsl:choose>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ********** Write the new point details out to a table ********** -->
<!-- **************************************************************** -->
<xsl:template name="OutputNewPointsTable">

  <xsl:call-template name="startTable">
    <xsl:with-param name="caption">New Boundary Point(s)</xsl:with-param>
  </xsl:call-template>
    <xsl:variable name="col2Name">
      <xsl:choose>
        <xsl:when test="$NECoords = 'true'">North</xsl:when>
        <xsl:otherwise>East</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="col3Name">
      <xsl:choose>
        <xsl:when test="$NECoords = 'true'">East</xsl:when>
        <xsl:otherwise>North</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <tr>
      <th align="center" bgcolor="silver" width="12%">Point</th>
      <th align="center" bgcolor="silver" width="20%"><xsl:value-of select="$col2Name"/></th>
      <th align="center" bgcolor="silver" width="20%"><xsl:value-of select="$col3Name"/></th>
      <th align="center" bgcolor="silver" width="20%">Elevation</th>
      <th align="center" bgcolor="silver" width="28%">Code</th>
    </tr>
    <xsl:for-each select="CreatedPoints/Item">
      <xsl:variable name="ptName" select="."/>
      <xsl:for-each select="/JOBFile/Reductions/Point[Name = $ptName]">
        <tr>
          <td align="left" width="12%">
            <xsl:value-of select="$ptName"/>
          </td>
          <td align="right" width="20">
            <xsl:call-template name="distValueString">
              <xsl:with-param name="distance">
                <xsl:choose>
                  <xsl:when test="$NECoords = 'true'">
                    <xsl:value-of select="Grid/North"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="Grid/East"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:with-param>
            </xsl:call-template>
          </td>
          <td align="right" width="20">
            <xsl:call-template name="distValueString">
              <xsl:with-param name="distance">
                <xsl:choose>
                  <xsl:when test="$NECoords = 'true'">
                    <xsl:value-of select="Grid/East"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="Grid/North"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:with-param>
            </xsl:call-template>
          </td>
          <td align="right" width="20">
            <xsl:call-template name="distValueString">
              <xsl:with-param name="distance" select="Grid/Elevation"/>
            </xsl:call-template>
          </td>
          <td align="left" width="28">
            <xsl:value-of select="Code"/>
          </td>
        </tr>
      </xsl:for-each>
    </xsl:for-each>
  <xsl:call-template name="endTable"/>

</xsl:template>


<!-- **************************************************************** -->
<!-- ****** Output a table containg the balance figure elements ***** -->
<!-- **************************************************************** -->
<xsl:template name="outputBalanceFigureEntities">
  <xsl:param name="caption"/>

  <!-- Start with the last entity in the ListOfSubEntities as this is the -->
  <!-- line between the 2 new points or between the pivot point and the   -->
  <!-- single new point.                                                  -->
  <xsl:variable name="subdividingLine">
    <xsl:copy-of select="ListOfSubEntities/Entity[last()]/*"/>
  </xsl:variable>

  <xsl:variable name="balanceListOfEntities">
    <!-- Add the subdividing line to the list -->
    <xsl:element name="Entity">
      <xsl:copy-of select="$subdividingLine"/>
    </xsl:element>

    <xsl:variable name="firstComplementEntity">
      <xsl:call-template name="GetFirstComplementEntity">
        <xsl:with-param name="subdividingLine" select="$subdividingLine"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="lastComplementEntity">
      <xsl:call-template name="GetLastComplementEntity">
        <xsl:with-param name="subdividingLine" select="$subdividingLine"/>
      </xsl:call-template>
    </xsl:variable>

    <!-- Check for situation where a 'pivot' computation ends up with the -->
    <!-- subdividing point on the same arc as the pivot point itself.     -->
    <xsl:variable name="firstComplementEntityEndsOnSubdividingLineStart">
      <xsl:call-template name="MatchingPosition">
        <xsl:with-param name="pos1" select="msxsl:node-set($firstComplementEntity)/Entity/End"/>
        <xsl:with-param name="pos2" select="msxsl:node-set($subdividingLine)/Start"/>
      </xsl:call-template>
    </xsl:variable>

    <!-- Check for the case where the subdividing line starts and -->
    <!-- ends on the same arc from the original figure.           -->
    <xsl:choose>
      <xsl:when test="(msxsl:node-set($firstComplementEntity)/Entity/Type = 'Arc') and
                      (msxsl:node-set($lastComplementEntity)/Entity/Type = 'Arc') and
                      (msxsl:node-set($firstComplementEntity)/Entity/Name = msxsl:node-set($lastComplementEntity)/Entity/Name)">

        <xsl:call-template name="BuildArcBetweenSubdividingLinePoints">
          <xsl:with-param name="firstComplementEntity" select="$firstComplementEntity"/>
          <xsl:with-param name="lastComplementEntity" select="$lastComplementEntity"/>
        </xsl:call-template>
      </xsl:when>

      <xsl:when test="$firstComplementEntityEndsOnSubdividingLineStart = 'true'">
        <xsl:copy-of select="$firstComplementEntity"/>
      </xsl:when>

      <xsl:otherwise>
        <!-- Add first complement entity if not empty to the list -->
        <xsl:if test="$firstComplementEntity != ''">
          <xsl:copy-of select="$firstComplementEntity"/>
        </xsl:if>

        <!-- Now work through the ListOfEntities matching end and start points until -->
        <!-- we get back to the start point of the subdividingLine                   -->
        <xsl:call-template name="AddIntermediateOriginalEntities">
          <xsl:with-param name="subdividingLine" select="$subdividingLine"/>
          <xsl:with-param name="firstComplementEntity" select="$firstComplementEntity"/>
          <xsl:with-param name="lastComplementEntity" select="$lastComplementEntity"/>
        </xsl:call-template>

        <!-- Add last complement entity if not empty to the list -->
        <xsl:if test="$lastComplementEntity != ''">
          <xsl:copy-of select="$lastComplementEntity"/>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- Now output the table of balance entities -->
  <xsl:for-each select="msxsl:node-set($balanceListOfEntities)">
    <xsl:call-template name="outputAreaEntities">
      <xsl:with-param name="caption" select="$caption"/>
    </xsl:call-template>
  </xsl:for-each>

</xsl:template>


<!-- **************************************************************** -->
<!-- **** Create arc element between the subdividing line points **** -->
<!-- **************************************************************** -->
<xsl:template name="BuildArcBetweenSubdividingLinePoints">
  <xsl:param name="firstComplementEntity"/>
  <xsl:param name="lastComplementEntity"/>

  <!-- Both complement elements are portions of the same arc - we only need to add the -->
  <!-- arc that starts with the Start point of the firstComplementEntity and ends with -->
  <!-- the End point of the lastComplementEntity. -->
  <xsl:element name="Entity">
    <xsl:element name="Type">Arc</xsl:element>
    <xsl:element name="Name">
      <xsl:value-of select="msxsl:node-set($firstComplementEntity)/Entity/Name"/>
    </xsl:element>
    <!-- Try to find the point name for this Start point using its position and looking in the Reductions section -->
    <xsl:variable name="startPtName">
      <xsl:call-template name="NameFromReductionsPointMatch">
        <xsl:with-param name="posn" select="msxsl:node-set($firstComplementEntity)/Entity/Start"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="Start">
      <xsl:element name="Name">
        <xsl:choose>
          <xsl:when test="$startPtName != ''">
            <xsl:value-of select="$startPtName"/>
          </xsl:when>
          <xsl:otherwise>N/A</xsl:otherwise>
        </xsl:choose>
      </xsl:element>
      <xsl:copy-of select="msxsl:node-set($firstComplementEntity)/Entity/Start/North"/>
      <xsl:copy-of select="msxsl:node-set($firstComplementEntity)/Entity/Start/East"/>
      <xsl:copy-of select="msxsl:node-set($firstComplementEntity)/Entity/Start/Elevation"/>
    </xsl:element>

    <!-- Try to find the point name for this End point using its position and looking in the Reductions section -->
    <xsl:variable name="endPtName">
      <xsl:call-template name="NameFromReductionsPointMatch">
        <xsl:with-param name="posn" select="msxsl:node-set($lastComplementEntity)/Entity/End"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:element name="End">
      <xsl:element name="Name">
        <xsl:choose>
          <xsl:when test="$endPtName != ''">
            <xsl:value-of select="$endPtName"/>
          </xsl:when>
          <xsl:otherwise>N/A</xsl:otherwise>
        </xsl:choose>
      </xsl:element>
      <xsl:copy-of select="msxsl:node-set($lastComplementEntity)/Entity/End/North"/>
      <xsl:copy-of select="msxsl:node-set($lastComplementEntity)/Entity/End/East"/>
      <xsl:copy-of select="msxsl:node-set($lastComplementEntity)/Entity/End/Elevation"/>
    </xsl:element>

    <xsl:copy-of select="msxsl:node-set($firstComplementEntity)/Entity/Center"/>

    <!-- Compute the ScribedAngle from the chord length and radius -->
    <xsl:variable name="chordLen">
      <xsl:call-template name="InverseDistance">
        <xsl:with-param name="deltaN" select="msxsl:node-set($firstComplementEntity)/Entity/Start/North - msxsl:node-set($lastComplementEntity)/Entity/End/North"/>
        <xsl:with-param name="deltaE" select="msxsl:node-set($firstComplementEntity)/Entity/Start/East - msxsl:node-set($lastComplementEntity)/Entity/End/East"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="radius">
      <xsl:call-template name="InverseDistance">
        <xsl:with-param name="deltaN" select="msxsl:node-set($firstComplementEntity)/Entity/Start/North - msxsl:node-set($lastComplementEntity)/Entity/Center/North"/>
        <xsl:with-param name="deltaE" select="msxsl:node-set($firstComplementEntity)/Entity/Start/East - msxsl:node-set($lastComplementEntity)/Entity/Center/East"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:variable name="halfScribedAngle">
      <xsl:call-template name="ArcSin">
        <xsl:with-param name="sinVal" select="($chordLen div 2.0) div $radius"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:element name="ScribedAngle">
      <xsl:value-of select="$halfScribedAngle * 360.0 div $Pi"/>
    </xsl:element>

    <xsl:copy-of select="msxsl:node-set($firstComplementEntity)/Entity/Direction"/>
  </xsl:element>
</xsl:template>


<!-- **************************************************************** -->
<!-- * Add the original figure entities between complement entities * -->
<!-- **************************************************************** -->
<xsl:template name="AddIntermediateOriginalEntities">
  <xsl:param name="subdividingLine"/>
  <xsl:param name="firstComplementEntity"/>
  <xsl:param name="lastComplementEntity"/>

  <xsl:variable name="startPosn">
    <xsl:choose>
      <xsl:when test="$firstComplementEntity = ''">  <!-- There is no firstComplementEntity so the start posn for the sequence must be the end of the subdividing line -->
        <xsl:copy-of select="msxsl:node-set($subdividingLine)/End/*"/>
      </xsl:when>
      <xsl:otherwise>  <!-- Otherwise the start posn for the sequence must be the end of the firstComplementEntity -->
        <xsl:copy-of select="msxsl:node-set($firstComplementEntity)/Entity/End/*"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="endPosn">
    <xsl:choose>
      <xsl:when test="$lastComplementEntity = ''">  <!-- There is no lastComplementEntity so the end posn for the sequence must be the start of the subdividing line -->
        <xsl:copy-of select="msxsl:node-set($subdividingLine)/Start/*"/>
      </xsl:when>
      <xsl:otherwise>  <!-- Otherwise the end posn for the sequence must be the start of the lastComplementEntity -->
        <xsl:copy-of select="msxsl:node-set($lastComplementEntity)/Entity/Start/*"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:call-template name="AddNextEntity">
    <xsl:with-param name="startPosn" select="$startPosn"/>
    <xsl:with-param name="endPosn" select="$endPosn"/>
  </xsl:call-template>
</xsl:template>


<!-- **************************************************************** -->
<!-- ********************* Add Next Entity ************************** -->
<!-- **************************************************************** -->
<xsl:template name="AddNextEntity">
  <xsl:param name="startPosn"/>
  <xsl:param name="endPosn"/>
  <xsl:param name="count" select="0"/>
  <xsl:param name="entitiesUsed" select="''"/> 
  
  <!-- Get the entity from the ListOfEntities that has the StartPosn -->
  <!-- as End position.                                              -->
  <xsl:variable name="nextEntity">
    <xsl:for-each select="ListOfEntities/Entity">
      <xsl:variable name="currPosn" select="position()"/>
      <xsl:variable name="entityUsed"> <!-- Want to ensure that entity has not already been used - can occur if figure crosses over itself -->
        <xsl:for-each select="msxsl:node-set($entitiesUsed)/entity[. = $currPosn]">
          <xsl:value-of select="'true'"/>
        </xsl:for-each>
      </xsl:variable>
      <xsl:if test="$entityUsed != 'true'">
        <xsl:variable name="matchingEndPt">
          <xsl:call-template name="MatchingPosition">
            <xsl:with-param name="pos1" select="$startPosn"/>
            <xsl:with-param name="pos2" select="End"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$matchingEndPt = 'true'">  <!-- Add entity in reversed direction -->
          <xsl:element name="Entity">
            <xsl:copy-of select="Type"/>
            <xsl:copy-of select="Name"/>

            <!-- Attempt to resolve the point names here -->
            <xsl:variable name="startPtName">
              <xsl:call-template name="GetStartNameForReversedEntity"/>
            </xsl:variable>
            <xsl:variable name="endPtName">
              <xsl:call-template name="GetEndNameForReversedEntity"/>
            </xsl:variable>

            <xsl:element name="Start">
              <xsl:element name="Name">
                <xsl:value-of select="$startPtName"/>  <!-- Use the point name we have fetched -->
              </xsl:element>
              <xsl:copy-of select="End/North"/>
              <xsl:copy-of select="End/East"/>
              <xsl:copy-of select="End/Elevation"/>
            </xsl:element>
            <xsl:element name="End">
              <xsl:element name="Name">
                <xsl:value-of select="$endPtName"/>    <!-- Use the point name we have fetched -->
              </xsl:element>
              <xsl:copy-of select="Start/North"/>
              <xsl:copy-of select="Start/East"/>
              <xsl:copy-of select="Start/Elevation"/>
            </xsl:element>

            <xsl:if test="Type = 'Arc'">
              <xsl:copy-of select="ScribedAngle"/>
              <xsl:element name="Direction">
                <xsl:choose>
                  <xsl:when test="Direction = 'Right'">Left</xsl:when>
                  <xsl:otherwise>Right</xsl:otherwise>
                </xsl:choose>
              </xsl:element>
            </xsl:if>
            
            <xsl:element name="elementPosn">
              <xsl:value-of select="position()"/>
            </xsl:element>  
          </xsl:element>
        </xsl:if>
      </xsl:if>
    </xsl:for-each>
  </xsl:variable>

  <xsl:copy-of select="msxsl:node-set($nextEntity)/Entity[1]"/> <!-- Add this entity to the balance entities node-set - take only first entity in case of a figure crossing itself -->
  
  <xsl:variable name="matchingEndPt">
    <xsl:call-template name="MatchingPosition">
      <xsl:with-param name="pos1" select="$endPosn"/>
      <xsl:with-param name="pos2" select="msxsl:node-set($nextEntity)/Entity/End"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="($matchingEndPt != 'true') and ($count &lt;= count(ListOfEntities/Entity))">  <!-- Haven't got to the end point yet - recurse the function. Use count to avoid possibility of infinite recursion -->
    <xsl:call-template name="AddNextEntity">
      <xsl:with-param name="startPosn" select="msxsl:node-set($nextEntity)/Entity/End"/>  <!-- Update to new startPosn -->
      <xsl:with-param name="endPosn" select="$endPosn"/>
      <xsl:with-param name="count" select="$count + 1"/>
      <xsl:with-param name="entitiesUsed">
        <xsl:for-each select="msxsl:node-set($entitiesUsed)/entity">              <!-- Add all the previously used entities -->
          <xsl:copy-of select="."/>
        </xsl:for-each>
        <xsl:element name="entity">
          <xsl:value-of select="msxsl:node-set($nextEntity)/Entity/elementPosn"/> <!-- Add in the last entity used -->
        </xsl:element>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:if>    

</xsl:template>


<!-- **************************************************************** -->
<!-- ****** Return the start point name for a reversed entity ******* -->
<!-- **************************************************************** -->
<xsl:template name="GetStartNameForReversedEntity">

  <!-- Need to get the end point name for the entity since we are reversing it -->
  <xsl:choose>
    <xsl:when test="End/Name != ''">    <!-- End point name already exists so use it -->
      <xsl:value-of select="End/Name"/>
    </xsl:when>
    <xsl:otherwise>  <!-- No end point name need to get it from next adjacent element in list -->
      <xsl:for-each select="following-sibling::Entity[1]">
        <xsl:call-template name="GetEntityStartPointName"/>
      </xsl:for-each>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template>


<!-- **************************************************************** -->
<!-- ******** Return the end point name for a reversed entity ******* -->
<!-- **************************************************************** -->
<xsl:template name="GetEndNameForReversedEntity">

  <!-- Need to get the start point name for the entity since we are reversing it -->
  <xsl:choose>
    <xsl:when test="Start/Name != ''">    <!-- Start point name already exists so use it -->
      <xsl:value-of select="Start/Name"/>
    </xsl:when>
    <xsl:otherwise>  <!-- No start point name need to get it from previous adjacent element in list -->
      <xsl:for-each select="preceding-sibling::Entity[1]">
        <xsl:call-template name="GetEntityEndPointName"/>
      </xsl:for-each>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template>


<!-- **************************************************************** -->
<!-- ** Return the complement entity at start of subdividing line *** -->
<!-- **************************************************************** -->
<xsl:template name="GetLastComplementEntity">
  <xsl:param name="subdividingLine"/>

  <!-- If the start point of the subdividingLine is in the same position -->
  <!-- as a point on the original figure then this means it is a pivot   -->
  <!-- point for a rotated subdividing line.                             -->
  <xsl:variable name="originalPosnMatch">
    <xsl:call-template name="OriginalPositionMatch">
      <xsl:with-param name="posn" select="msxsl:node-set($subdividingLine)/Start"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$originalPosnMatch != 'true'">
    <!-- Find the Element in the ListOfSubEntities that ends with the -->
    <!-- start point of the subdividingLine.  Return the complement   -->
    <!-- portion of this Entity.                                      -->
    <xsl:variable name="splitEntity">
      <xsl:for-each select="ListOfSubEntities/Entity">
        <xsl:variable name="matchingEndPt">
          <xsl:call-template name="MatchingPosition">
            <xsl:with-param name="pos1" select="msxsl:node-set($subdividingLine)/Start"/>
            <xsl:with-param name="pos2" select="End"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$matchingEndPt = 'true'">
          <xsl:copy-of select="./*"/>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>


    <!-- Now need to locate the Element in the ListOfEntities that has the -->
    <!-- start point of the splitEntity as its start point.                -->
    <xsl:variable name="originalEntity">
      <xsl:for-each select="ListOfEntities/Entity">
        <xsl:variable name="matchingStartPt">
          <xsl:call-template name="MatchingPosition">
            <xsl:with-param name="pos1" select="msxsl:node-set($splitEntity)/Start"/>
            <xsl:with-param name="pos2" select="Start"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$matchingStartPt = 'true'">
          <xsl:copy-of select="./*"/>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>

    <!-- Now need to build the portion of the original Entity that is the -->
    <!-- complement of the splitEntity.                                   -->
    <xsl:element name="Entity">
      <xsl:copy-of select="msxsl:node-set($originalEntity)/Type"/>
      <xsl:copy-of select="msxsl:node-set($originalEntity)/Name"/>
      <!-- Try to find the point name for this Start point using its position and looking in the Reductions section -->
      <xsl:variable name="startPtName">
        <xsl:call-template name="NameFromReductionsPointMatch">
          <xsl:with-param name="posn" select="msxsl:node-set($originalEntity)/End"/>
        </xsl:call-template>
      </xsl:variable>
      <xsl:element name="Start">  <!-- End contents output to Start entity  -->
        <xsl:element name="Name">
          <xsl:value-of select="$startPtName"/>
        </xsl:element>
        <xsl:copy-of select="msxsl:node-set($originalEntity)/End/North"/>
        <xsl:copy-of select="msxsl:node-set($originalEntity)/End/East"/>
        <xsl:copy-of select="msxsl:node-set($originalEntity)/End/Elevation"/>
      </xsl:element>

      <xsl:copy-of select="msxsl:node-set($splitEntity)/End"/>

      <xsl:if test="msxsl:node-set($originalEntity)/Type = 'Arc'">
        <xsl:copy-of select="msxsl:node-set($originalEntity)/Center"/>
        <!-- Add computed balance scribed angle -->
        <xsl:element name="ScribedAngle">
          <xsl:value-of select="msxsl:node-set($originalEntity)/ScribedAngle - msxsl:node-set($splitEntity)/ScribedAngle"/>
        </xsl:element>
        <!-- Add the reversed direction -->
        <xsl:element name="Direction">
          <xsl:choose>
            <xsl:when test="msxsl:node-set($originalEntity)/Direction = Right">Left</xsl:when>
            <xsl:otherwise>Right</xsl:otherwise>
          </xsl:choose>
        </xsl:element>
      </xsl:if>
    </xsl:element>
  </xsl:if>

</xsl:template>


<!-- **************************************************************** -->
<!-- **** Return the complement entity at end of subdividing line *** -->
<!-- **************************************************************** -->
<xsl:template name="GetFirstComplementEntity">
  <xsl:param name="subdividingLine"/>
  
  <!-- If the end point of the subdividingLine is in the same position -->
  <!-- as a point on the original figure then this means it is a pivot -->
  <!-- point for a rotated subdividing line.                           -->
  <xsl:variable name="originalPosnMatch">
    <xsl:call-template name="OriginalPositionMatch">
      <xsl:with-param name="posn" select="msxsl:node-set($subdividingLine)/End"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:if test="$originalPosnMatch != 'true'">
    <!-- Find the Element in the ListOfSubEntities that starts with the -->
    <!-- end point of the subdividingLine.  Return the complement       -->
    <!-- portion of this Entity.                                        -->
    <xsl:variable name="splitEntity">
      <xsl:for-each select="ListOfSubEntities/Entity">
        <xsl:variable name="matchingStartPt">
          <xsl:call-template name="MatchingPosition">
            <xsl:with-param name="pos1" select="msxsl:node-set($subdividingLine)/End"/>
            <xsl:with-param name="pos2" select="Start"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$matchingStartPt = 'true'">
          <xsl:copy-of select="./*"/>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>

    <!-- Now need to locate the Element in the ListOfEntities that has the -->
    <!-- end point of the splitEntity as its end point.                    -->
    <xsl:variable name="originalEntity">
      <xsl:for-each select="ListOfEntities/Entity">
        <xsl:variable name="matchingEndPt">
          <xsl:call-template name="MatchingPosition">
            <xsl:with-param name="pos1" select="msxsl:node-set($splitEntity)/End"/>
            <xsl:with-param name="pos2" select="End"/>
          </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$matchingEndPt = 'true'">
          <xsl:copy-of select="./*"/>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>

    <!-- Now need to build the portion of the original Entity that is the -->
    <!-- complement of the splitEntity.                                   -->
    <xsl:element name="Entity">
      <xsl:copy-of select="msxsl:node-set($originalEntity)/Type"/>
      <xsl:copy-of select="msxsl:node-set($originalEntity)/Name"/>
      <xsl:copy-of select="msxsl:node-set($splitEntity)/Start"/>
      <xsl:element name="End">
        <xsl:copy-of select="msxsl:node-set($originalEntity)/Start/*"/>  <!-- Start element contents output to End element -->
      </xsl:element>
      <xsl:if test="msxsl:node-set($originalEntity)/Type = 'Arc'">
        <xsl:copy-of select="msxsl:node-set($originalEntity)/Center"/>
        <!-- Add computed balance scribed angle -->
        <xsl:element name="ScribedAngle">
          <xsl:value-of select="msxsl:node-set($originalEntity)/ScribedAngle - msxsl:node-set($splitEntity)/ScribedAngle"/>
        </xsl:element>
        <!-- Add the reversed direction -->
        <xsl:element name="Direction">
          <xsl:choose>
            <xsl:when test="msxsl:node-set($originalEntity)/Direction = Right">Left</xsl:when>
            <xsl:otherwise>Right</xsl:otherwise>
          </xsl:choose>
        </xsl:element>
      </xsl:if>
    </xsl:element>
  </xsl:if>
</xsl:template>


<!-- **************************************************************** -->
<!-- * Checks if supplied position matches point on original figure * -->
<!-- **************************************************************** -->
<xsl:template name="OriginalPositionMatch">
  <xsl:param name="posn"/>

  <xsl:variable name="test">
    <xsl:for-each select="ListOfEntities/Entity">
      <xsl:variable name="startPtMatch">
        <xsl:call-template name="MatchingPosition">
          <xsl:with-param name="pos1" select="$posn"/>
          <xsl:with-param name="pos2" select="Start"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="endPtMatch">
        <xsl:call-template name="MatchingPosition">
          <xsl:with-param name="pos1" select="$posn"/>
          <xsl:with-param name="pos2" select="End"/>
        </xsl:call-template>
      </xsl:variable>
      
      <xsl:if test="($startPtMatch = 'true') or ($endPtMatch = 'true')">true</xsl:if>
    </xsl:for-each>
  </xsl:variable>

  <!-- Returns true or false -->
  <xsl:choose>
    <xsl:when test="$test != ''">true</xsl:when>
    <xsl:otherwise>false</xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ******* Compares two positions and returns true or false ******* -->
<!-- **************************************************************** -->
<xsl:template name="MatchingPosition">
  <xsl:param name="pos1"/>
  <xsl:param name="pos2"/>
  <xsl:param name="matchHzPosOnly" select="'true'"/>

  <!-- Compares the coordinate values in the testPos node set variable with the current node position -->
  <xsl:variable name="deltaN" select="msxsl:node-set($pos1)//North - msxsl:node-set($pos2)//North"/>
  <xsl:variable name="deltaE" select="msxsl:node-set($pos1)//East - msxsl:node-set($pos2)//East"/>
  <xsl:variable name="deltaEle">
    <xsl:choose>
      <xsl:when test="(string(number(msxsl:node-set($pos1)//Elevation)) = 'NaN') or
                      (string(number(msxsl:node-set($pos2)//Elevation)) = 'NaN')">0</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="msxsl:node-set($pos1)//Elevation - msxsl:node-set($pos2)//Elevation"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="absDeltaN" select="concat(substring('-',2 - ($deltaN &lt; 0)), '1') * $deltaN"/>
  <xsl:variable name="absDeltaE" select="concat(substring('-',2 - ($deltaE &lt; 0)), '1') * $deltaE"/>
  <xsl:variable name="absDeltaEle">
    <xsl:choose>
      <xsl:when test="$matchHzPosOnly = 'true'">0</xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="concat(substring('-',2 - ($deltaEle &lt; 0)), '1') * $deltaEle"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="($absDeltaN &lt; 0.0001) and ($absDeltaE &lt; 0.0001) and
                    ($absDeltaEle &lt; 0.0001)">true</xsl:when>
    <xsl:otherwise>false</xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ** Return the point name if matching Reductions posn located *** -->
<!-- **************************************************************** -->
<xsl:template name="NameFromReductionsPointMatch">
  <xsl:param name="posn"/>

  <xsl:variable name="ptName">
    <xsl:for-each select="msxsl:node-set($reducedPoints)/Point"> <!-- Use the reducedPoints node-set variable to be independent of context -->
      <xsl:variable name="matches">
        <xsl:call-template name="MatchingPosition">
          <xsl:with-param name="pos1" select="$posn"/>
          <xsl:with-param name="pos2" select="Grid"/>
        </xsl:call-template>
      </xsl:variable>
      
      <xsl:if test="$matches = 'true'">
        <xsl:element name="name">
          <xsl:value-of select="Name"/>
        </xsl:element>
      </xsl:if>
    </xsl:for-each>
  </xsl:variable>
  
  <xsl:if test="count(msxsl:node-set($ptName)/name) != 0">
    <xsl:value-of select="msxsl:node-set($ptName)/name[1]"/>  <!-- In case of multiple position matches - return first -->
  </xsl:if>
</xsl:template>


<!-- **************************************************************** -->
<!-- *********** Return the length of the subdividing line ********** -->
<!-- **************************************************************** -->
<xsl:template name="LengthOfSubdividingLine">

  <xsl:choose>
    <xsl:when test="count(CreatedPoints/Item) != 0">
      <xsl:variable name="pt1Name" select="CreatedPoints/Item[1]"/>

      <xsl:variable name="pt2Name">
        <xsl:choose>
          <xsl:when test="count(CreatedPoints/Item) = 2">
            <xsl:value-of select="CreatedPoints/Item[2]"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:choose>
              <xsl:when test="ListOfSubEntities/Entity[last()]/Start/Name != ''">
                <xsl:value-of select="ListOfSubEntities/Entity[1]/Start/Name"/>  <!-- Get the pivot point name -->
              </xsl:when>
              <xsl:otherwise>
                <xsl:call-template name="NameFromReductionsPointMatch">
                  <xsl:with-param name="posn" select="ListOfSubEntities/Entity[last()]/Start"/>
                </xsl:call-template>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>


      <xsl:variable name="pt1N">
        <xsl:for-each select="/JOBFile/Reductions/Point[Name = $pt1Name]">
          <xsl:value-of select="Grid/North"/>
        </xsl:for-each>
      </xsl:variable>

      <xsl:variable name="pt1E">
        <xsl:for-each select="/JOBFile/Reductions/Point[Name = $pt1Name]">
          <xsl:value-of select="Grid/East"/>
        </xsl:for-each>
      </xsl:variable>

      <xsl:variable name="pt2N">
        <xsl:for-each select="/JOBFile/Reductions/Point[Name = $pt2Name]">
          <xsl:value-of select="Grid/North"/>
        </xsl:for-each>
      </xsl:variable>

      <xsl:variable name="pt2E">
        <xsl:for-each select="/JOBFile/Reductions/Point[Name = $pt2Name]">
          <xsl:value-of select="Grid/East"/>
        </xsl:for-each>
      </xsl:variable>

      <xsl:call-template name="InverseDistance">
        <xsl:with-param name="deltaN" select="$pt1N - $pt2N"/>
        <xsl:with-param name="deltaE" select="$pt1E - $pt2E"/>
      </xsl:call-template>
    </xsl:when>
    
    <xsl:otherwise>  <!-- New point(s) have not been saved -->
      <!-- The last Entity in the ListOfSubEntities element will be the subdividing line -->
      <xsl:for-each select="ListOfSubEntities/Entity[last()]">
        <xsl:call-template name="InverseDistance">
          <xsl:with-param name="deltaN" select="Start/North - End/North"/>
          <xsl:with-param name="deltaE" select="Start/East - End/East"/>
        </xsl:call-template>
      </xsl:for-each>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************* Return an area value string with units *********** -->
<!-- **************************************************************** -->
<xsl:template name="areaValueString">
  <xsl:param name="area"/>

  <xsl:variable name="areaVal" select="$area * $AreaConvFactor"/>

  <xsl:choose>
    <xsl:when test="$AreaUnit = 'SquareMetres'">
      <xsl:value-of select="format-number($areaVal, $DecPl2, 'Standard')"/>
      <xsl:text>m&#0178;</xsl:text>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'SquareMiles'">
      <xsl:value-of select="format-number($areaVal, $DecPl5, 'Standard')"/>
      <xsl:text>mi&#0178;</xsl:text>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'SquareFeet'">
      <xsl:value-of select="format-number($areaVal, $DecPl2, 'Standard')"/>
      <xsl:text>ft&#0178;</xsl:text>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'SquareUSSurveyFeet'">
      <xsl:value-of select="format-number($areaVal, $DecPl2, 'Standard')"/>
      <xsl:text>sft&#0178;</xsl:text>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'Acres'">
      <xsl:value-of select="format-number($areaVal, $DecPl4, 'Standard')"/>
      <xsl:text>A</xsl:text>
    </xsl:when>
    <xsl:when test="$AreaUnit = 'Hectares'">
      <xsl:value-of select="format-number($areaVal, $DecPl4, 'Standard')"/>
      <xsl:text>Ha</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="format-number($areaVal, $DecPl2, 'Standard')"/>
      <xsl:text>m&#0178;</xsl:text>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template>


<!-- **************************************************************** -->
<!-- ********* Return an distance value string with units *********** -->
<!-- **************************************************************** -->
<xsl:template name="distValueString">
  <xsl:param name="distance"/>

  <xsl:variable name="dist" select="$distance * $DistConvFactor"/>

  <xsl:choose>
    <xsl:when test="$DistUnit = 'Metres'">
      <xsl:value-of select="format-number($dist, $DecPl3, 'Standard')"/>
      <xsl:text>m</xsl:text>
    </xsl:when>
    <xsl:when test="$DistUnit = 'InternationalFeet'">
      <xsl:value-of select="format-number($dist, $DecPl3, 'Standard')"/>
      <xsl:text>ift</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="format-number($dist, $DecPl3, 'Standard')"/>
      <xsl:text>sft</xsl:text>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template>


<!-- **************************************************************** -->
<!-- *************** Return an arc element point name *************** -->
<!-- **************************************************************** -->
<xsl:template name="ArcPointName">
  <xsl:param name="arcName"/>
  <xsl:param name="startPoint" select="'true'"/>
  <xsl:param name="posn"/>

  <xsl:variable name="ptName">
    <xsl:for-each select="msxsl:node-set($arcRecords)/*[Name = $arcName]">
      <xsl:choose>
        <xsl:when test="$startPoint = 'true'">
          <xsl:value-of select="StartPoint"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="EndPoint"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="$ptName != ''">
      <!-- We have got a point name - now check that the passed in coords match the point position -->
      <xsl:variable name="redPosn">
        <xsl:for-each select="key('reducedPt-search', $ptName)">
          <xsl:copy-of select="Grid/*"/>
        </xsl:for-each>
      </xsl:variable>

      <xsl:variable name="positionsMatch">
        <xsl:call-template name="MatchingPosition">
          <xsl:with-param name="pos1" select="$posn"/>
          <xsl:with-param name="pos2" select="$redPosn"/>
        </xsl:call-template>
      </xsl:variable>
      
      <xsl:choose>
        <xsl:when test="$positionsMatch = 'true'">
          <xsl:value-of select="$ptName"/>
        </xsl:when>
        <xsl:otherwise>
          <!-- Check for a match against a Reductions point -->
          <xsl:variable name="matchedPtName">
            <xsl:call-template name="NameFromReductionsPointMatch">
              <xsl:with-param name="posn" select="$posn"/>
            </xsl:call-template>
          </xsl:variable>

          <xsl:choose>
            <xsl:when test="$matchedPtName != ''">
              <xsl:value-of select="$matchedPtName"/>
            </xsl:when>
            <xsl:otherwise>N/A</xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>  <!-- Arc element not found - could be background element so return arcName suffixed with /Start or /End as appropriate -->
      <!-- Check for a matching database position first -->
      <xsl:variable name="matchedPtName">
        <xsl:call-template name="NameFromReductionsPointMatch">
          <xsl:with-param name="posn" select="$posn"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$matchedPtName != ''">
          <xsl:value-of select="$matchedPtName"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$arcName"/>
          <xsl:choose>
            <xsl:when test="$startPoint = 'true'">/Start</xsl:when>
            <xsl:otherwise>/End</xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- *************** Return a line element point name *************** -->
<!-- **************************************************************** -->
<xsl:template name="linePointName">
  <xsl:param name="lineName"/>
  <xsl:param name="startPoint" select="'true'"/>
  <xsl:param name="posn"/>

  <xsl:variable name="ptName">
    <xsl:for-each select="msxsl:node-set($lineRecords)/*[Name = $lineName]">
      <xsl:choose>
        <xsl:when test="$startPoint = 'true'">
          <xsl:value-of select="StartPoint"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="EndPoint"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:variable>
  
  <xsl:choose>
    <xsl:when test="$ptName != ''">
      <!-- We have got a point name - now check that the passed in coords match the point position -->
      <xsl:variable name="redPosn">
        <xsl:for-each select="key('reducedPt-search', $ptName)">
          <xsl:copy-of select="Grid/*"/>
        </xsl:for-each>
      </xsl:variable>

      <xsl:variable name="positionsMatch">
        <xsl:call-template name="MatchingPosition">
          <xsl:with-param name="pos1" select="$posn"/>
          <xsl:with-param name="pos2" select="$redPosn"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$positionsMatch = 'true'">
          <xsl:value-of select="$ptName"/>
        </xsl:when>
        <xsl:otherwise>
          <!-- Check for a match against a Reductions point -->
          <xsl:variable name="matchedPtName">
            <xsl:call-template name="NameFromReductionsPointMatch">
              <xsl:with-param name="posn" select="$posn"/>
            </xsl:call-template>
          </xsl:variable>

          <xsl:choose>
            <xsl:when test="$matchedPtName != ''">
              <xsl:value-of select="$matchedPtName"/>
            </xsl:when>
            <xsl:otherwise>N/A</xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise>  <!-- Line element not found - could be background element so return lineName suffixed with /Start or /End as appropriate -->
      <!-- Check for a matching database position first -->
      <xsl:variable name="matchedPtName">
        <xsl:call-template name="NameFromReductionsPointMatch">
          <xsl:with-param name="posn" select="$posn"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:choose>
        <xsl:when test="$matchedPtName != ''">
          <xsl:value-of select="$matchedPtName"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$lineName"/>
          <xsl:choose>
            <xsl:when test="$startPoint = 'true'">/Start</xsl:when>
            <xsl:otherwise>/End</xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ***************** Return Formatted Date String ***************** -->
<!-- **************************************************************** -->
<xsl:template name="formattedDate">
  <xsl:param name="timeStamp"/>
  
  <xsl:variable name="date" select="substring($timeStamp, 9, 2)"/>
  
  <xsl:variable name="month">
    <xsl:variable name="monthNbr" select="substring($timeStamp, 6, 2)"/>
    <xsl:choose>
      <xsl:when test="number($monthNbr) = 1">Jan</xsl:when>
      <xsl:when test="number($monthNbr) = 2">Feb</xsl:when>
      <xsl:when test="number($monthNbr) = 3">Mar</xsl:when>
      <xsl:when test="number($monthNbr) = 4">Apr</xsl:when>
      <xsl:when test="number($monthNbr) = 5">May</xsl:when>
      <xsl:when test="number($monthNbr) = 6">Jun</xsl:when>
      <xsl:when test="number($monthNbr) = 7">Jul</xsl:when>
      <xsl:when test="number($monthNbr) = 8">Aug</xsl:when>
      <xsl:when test="number($monthNbr) = 9">Sep</xsl:when>
      <xsl:when test="number($monthNbr) = 10">Oct</xsl:when>
      <xsl:when test="number($monthNbr) = 11">Nov</xsl:when>
      <xsl:when test="number($monthNbr) = 12">Dec</xsl:when>
    </xsl:choose>
  </xsl:variable>
  
  <xsl:value-of select="concat($date, ' ', $month, ' ', substring($timeStamp, 1, 4))"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************************* Start Table ************************** -->
<!-- **************************************************************** -->
<xsl:template name="startTable">
  <xsl:param name="includeBorders" select="'Yes'"/>
  <xsl:param name="tableWidth" select="100"/>
  <xsl:param name="caption"/>
  <xsl:param name="captionFontSize" select="2"/>  <!-- 2 is the standard font size -->

  <xsl:choose>
    <xsl:when test="$includeBorders = 'Yes'">
      <xsl:value-of disable-output-escaping="yes" select="concat('&lt;table border=1 width=', $tableWidth, '% cellpadding=4 cellspacing=0 bordercolor=silver bordercolordark=silver rules=all&gt;')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of disable-output-escaping="yes" select="concat('&lt;table border=0 width=', $tableWidth, '% cellpadding=4 cellspacing=0 bordercolor=silver bordercolordark=silver rules=cols&gt;')"/>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:if test="$caption != ''">
    <caption align="top"><b><font size="{$captionFontSize}"><p align="left"><xsl:value-of select="$caption"/></p></font></b></caption>
  </xsl:if>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************************** End Table *************************** -->
<!-- **************************************************************** -->
<xsl:template name="endTable">
  <xsl:value-of disable-output-escaping="yes" select="'&lt;/table&gt;'"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ****************** Separating Line Output ********************** -->
<!-- **************************************************************** -->
<xsl:template name="separatingLine">
  <hr/>
</xsl:template>


<!-- **************************************************************** -->
<!-- *********************** Blank Line Output ********************** -->
<!-- **************************************************************** -->
<xsl:template name="blankLine">
  <br/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ********************** Format a DMS Angle ********************** -->
<!-- **************************************************************** -->
<xsl:template name="FormatDMSAngle">
  <xsl:param name="DecimalAngle"/>
  <xsl:param name="SecDecPlaces" select="0"/>
  <xsl:param name="useSymbols" select="'true'"/>

  <xsl:variable name="DegreesSymbol">
    <xsl:choose>
      <xsl:when test="$useSymbols = 'true'">&#0176;</xsl:when>
      <xsl:otherwise>.</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="MinutesSymbol">
    <xsl:choose>
      <xsl:when test="$useSymbols = 'true'">'</xsl:when>
      <xsl:otherwise></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="SecondsSymbol">
    <xsl:choose>
      <xsl:when test="$useSymbols = 'true'">&quot;</xsl:when>
      <xsl:otherwise></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="Sign">
    <xsl:if test="$DecimalAngle &lt; '0.0'">-1</xsl:if>
    <xsl:if test="$DecimalAngle &gt;= '0.0'">1</xsl:if>
  </xsl:variable>

  <xsl:variable name="PosDecimalDegrees" select="number($DecimalAngle * $Sign)"/>

  <xsl:variable name="PositiveDecimalDegrees">  <!-- Ensure an angle very close to 360° is treated as 0° -->
    <xsl:choose>
      <xsl:when test="(360.0 - $PosDecimalDegrees) &lt; 0.00001">
        <xsl:value-of select="0"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$PosDecimalDegrees"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="decPlFmt">
    <xsl:choose>
      <xsl:when test="$SecDecPlaces = 0"><xsl:value-of select="''"/></xsl:when>
      <xsl:when test="$SecDecPlaces = 1"><xsl:value-of select="'.0'"/></xsl:when>
      <xsl:when test="$SecDecPlaces = 2"><xsl:value-of select="'.00'"/></xsl:when>
      <xsl:when test="$SecDecPlaces = 3"><xsl:value-of select="'.000'"/></xsl:when>
      <xsl:when test="$SecDecPlaces = 4"><xsl:value-of select="'.0000'"/></xsl:when>
      <xsl:when test="$SecDecPlaces = 5"><xsl:value-of select="'.00000'"/></xsl:when>
      <xsl:otherwise><xsl:value-of select="''"/></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="Degrees" select="floor($PositiveDecimalDegrees)"/>
  <xsl:variable name="DecimalMinutes" select="number(number($PositiveDecimalDegrees - $Degrees) * 60 )"/>
  <xsl:variable name="Minutes" select="floor($DecimalMinutes)"/>
  <xsl:variable name="Seconds" select="number(number($DecimalMinutes - $Minutes)*60)"/>

  <xsl:variable name="PartiallyNormalisedMinutes">
    <xsl:if test="number(format-number($Seconds, concat('00', $decPlFmt))) = 60"><xsl:value-of select="number($Minutes + 1)"/></xsl:if>
    <xsl:if test="not(number(format-number($Seconds, concat('00', $decPlFmt))) = 60)"><xsl:value-of select="$Minutes"/></xsl:if>
  </xsl:variable>

  <xsl:variable name="NormalisedSeconds">
    <xsl:if test="number(format-number($Seconds, concat('00', $decPlFmt))) = 60"><xsl:value-of select="0"/></xsl:if>
    <xsl:if test="not(number(format-number($Seconds, concat('00', $decPlFmt))) = 60)"><xsl:value-of select="$Seconds"/></xsl:if>
  </xsl:variable>

  <xsl:variable name="PartiallyNormalisedDegrees">
    <xsl:if test="format-number($PartiallyNormalisedMinutes, '0') = '60'"><xsl:value-of select="number($Degrees + 1)"/></xsl:if>
    <xsl:if test="not(format-number($PartiallyNormalisedMinutes, '0') = '60')"><xsl:value-of select="$Degrees"/></xsl:if>
  </xsl:variable>

  <xsl:variable name="NormalisedDegrees">
    <xsl:if test="format-number($PartiallyNormalisedDegrees, '0') = '360'"><xsl:value-of select="0"/></xsl:if>
    <xsl:if test="not(format-number($PartiallyNormalisedDegrees, '0') = '360')"><xsl:value-of select="$PartiallyNormalisedDegrees"/></xsl:if>
  </xsl:variable>

  <xsl:variable name="NormalisedMinutes">
    <xsl:if test="format-number($PartiallyNormalisedMinutes, '00') = '60'"><xsl:value-of select="0"/></xsl:if>
    <xsl:if test="not(format-number($PartiallyNormalisedMinutes, '00') = '60')"><xsl:value-of select="$PartiallyNormalisedMinutes"/></xsl:if>
  </xsl:variable>

  <xsl:if test="$Sign = -1">-</xsl:if>
  <xsl:value-of select="format-number($NormalisedDegrees, '0')"/>
  <xsl:value-of select="$DegreesSymbol"/>
  <xsl:value-of select="format-number($NormalisedMinutes, '00')"/>
  <xsl:value-of select="$MinutesSymbol"/>
  <xsl:choose>
    <xsl:when test="$useSymbols = 'true'">
      <xsl:value-of select="format-number($NormalisedSeconds, concat('00', $decPlFmt))"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="translate(format-number($NormalisedSeconds, concat('00', $decPlFmt)), '.', '')"/>
    </xsl:otherwise>
  </xsl:choose>
  <xsl:value-of select="$SecondsSymbol"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ******************* Format a Quadrant Bearing ****************** -->
<!-- **************************************************************** -->
<xsl:template name="FormatQuadrantBearing">
  <xsl:param name="DecimalAngle"/>
  <xsl:param name="SecDecPlaces" select="0"/>

  <xsl:choose>
    <!-- Null azimuth value -->
    <xsl:when test="string(number($DecimalAngle))='NaN'">
      <xsl:value-of select="'?'"/>
    </xsl:when>
    <!-- There is an azimuth value -->
    <xsl:otherwise>
      <xsl:variable name="QuadrantAngle">
        <xsl:if test="($DecimalAngle &lt;= '90.0')">
          <xsl:value-of select="number ( $DecimalAngle )"/>
        </xsl:if>
        <xsl:if test="($DecimalAngle &gt; '90.0') and ($DecimalAngle &lt;= '180.0')">
          <xsl:value-of select="number( 180.0 - $DecimalAngle )"/>
        </xsl:if>
        <xsl:if test="($DecimalAngle &gt; '180.0') and ($DecimalAngle &lt; '270.0')">
          <xsl:value-of select="number( $DecimalAngle - 180.0 )"/>
        </xsl:if>
        <xsl:if test="($DecimalAngle &gt;= '270.0') and ($DecimalAngle &lt;= '360.0')">
          <xsl:value-of select="number( 360.0 - $DecimalAngle )"/>
        </xsl:if>
      </xsl:variable>

      <xsl:variable name="QuadrantPrefix">
        <xsl:if test="($DecimalAngle &lt;= '90.0') or ($DecimalAngle &gt;= '270.0')">N</xsl:if>
        <xsl:if test="($DecimalAngle &gt; '90.0') and ($DecimalAngle &lt; '270.0')">S</xsl:if>
      </xsl:variable>

      <xsl:variable name="QuadrantSuffix">
        <xsl:if test="($DecimalAngle &lt;= '180.0')">E</xsl:if>
        <xsl:if test="($DecimalAngle &gt; '180.0')">W</xsl:if>
      </xsl:variable>

      <xsl:value-of select="$QuadrantPrefix"/>
      <xsl:choose>
        <xsl:when test="$AngleUnit='DMSDegrees'">
          <xsl:call-template name="FormatDMSAngle">
            <xsl:with-param name="DecimalAngle" select="$QuadrantAngle"/>
            <xsl:with-param name="SecDecPlaces" select="$SecDecPlaces"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="FormatAngle">
            <xsl:with-param name="TheAngle" select="$QuadrantAngle"/>
            <xsl:with-param name="SecDecPlaces" select="$SecDecPlaces"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:value-of select="$QuadrantSuffix"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************ Output Angle in Appropriate Format **************** -->
<!-- **************************************************************** -->
<xsl:template name="FormatAngle">
  <xsl:param name="TheAngle"/>
  <xsl:param name="SecDecPlaces" select="0"/>
  <xsl:param name="DMSOutput" select="'false'"/>  <!-- Can be used to force DMS output -->
  <xsl:param name="useSymbols" select="'true'"/>

  <xsl:choose>
    <!-- Null angle value -->
    <xsl:when test="string(number($TheAngle))='NaN'">
      <xsl:value-of select="''"/>
    </xsl:when>
    <!-- There is an angle value -->
    <xsl:otherwise>
      <xsl:choose>
        <xsl:when test="($AngleUnit='DMSDegrees') or not($DMSOutput = 'false')">
          <xsl:call-template name="FormatDMSAngle">
            <xsl:with-param name="DecimalAngle" select="$TheAngle"/>
            <xsl:with-param name="SecDecPlaces" select="$SecDecPlaces"/>
            <xsl:with-param name="useSymbols" select="$useSymbols"/>
          </xsl:call-template>
        </xsl:when>

        <xsl:when test="($AngleUnit='Gons') and ($DMSOutput = 'false')">
          <xsl:choose>
            <xsl:when test="$SecDecPlaces > 0">  <!-- More accurate angle output required -->
              <xsl:value-of select="format-number($TheAngle * $AngleConvFactor, $DecPl8, 'Standard')"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="format-number($TheAngle * $AngleConvFactor, $DecPl5, 'Standard')"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>

        <xsl:when test="($AngleUnit='Mils') and ($DMSOutput = 'false')">
          <xsl:choose>
            <xsl:when test="$SecDecPlaces > 0">  <!-- More accurate angle output required -->
              <xsl:value-of select="format-number($TheAngle * $AngleConvFactor, $DecPl6, 'Standard')"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="format-number($TheAngle * $AngleConvFactor, $DecPl4, 'Standard')"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>

        <xsl:when test="($AngleUnit='DecimalDegrees') and ($DMSOutput = 'false')">
          <xsl:choose>
            <xsl:when test="$SecDecPlaces > 0">  <!-- More accurate angle output required -->
              <xsl:value-of select="format-number($TheAngle * $AngleConvFactor, $DecPl8, 'Standard')"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="format-number($TheAngle * $AngleConvFactor, $DecPl5, 'Standard')"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************ Output Azimuth in Appropriate Format ************** -->
<!-- **************************************************************** -->
<xsl:template name="FormatAzimuth">
  <xsl:param name="TheAzimuth"/>
  <xsl:param name="SecDecPlaces" select="0"/>
  <xsl:param name="DMSOutput" select="'false'"/>
  <xsl:param name="useSymbols" select="'true'"/>

  <xsl:choose>
    <xsl:when test="$azimuthFormat = 'QuadrantBearings'">
      <xsl:call-template name="FormatQuadrantBearing">
        <xsl:with-param name="DecimalAngle" select="$TheAzimuth"/>
        <xsl:with-param name="SecDecPlaces" select="$SecDecPlaces"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="FormatAngle">
        <xsl:with-param name="TheAngle" select="$TheAzimuth"/>
        <xsl:with-param name="SecDecPlaces" select="$SecDecPlaces"/>
        <xsl:with-param name="DMSOutput" select="$DMSOutput"/>
        <xsl:with-param name="useSymbols" select="$useSymbols"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ****************** Compute Inverse Distance ******************** -->
<!-- **************************************************************** -->
<xsl:template name="InverseDistance">
  <xsl:param name="deltaN"/>
  <xsl:param name="deltaE"/>

  <!-- Compute the inverse distance from the deltas -->
  <xsl:call-template name="Sqrt">
    <xsl:with-param name="num" select="$deltaN * $deltaN + $deltaE * $deltaE"/>
  </xsl:call-template>
</xsl:template>


<!-- **************************************************************** -->
<!-- ******************* Compute Inverse Azimuth ******************** -->
<!-- **************************************************************** -->
<xsl:template name="InverseAzimuth">
  <xsl:param name="deltaN"/>
  <xsl:param name="deltaE"/>

  <!-- Compute the inverse azimuth from the deltas -->
  <xsl:variable name="absDeltaN" select="concat(substring('-',2 - ($deltaN &lt; 0)), '1') * $deltaN"/>
  <xsl:variable name="absDeltaE" select="concat(substring('-',2 - ($deltaE &lt; 0)), '1') * $deltaE"/>

  <xsl:variable name="flag">
    <xsl:choose>
      <xsl:when test="$absDeltaE &gt; $absDeltaN">
        <xsl:value-of select="1"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="0"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="adjDeltaN">
    <xsl:choose>
      <xsl:when test="$flag">
        <xsl:value-of select="$absDeltaE"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$absDeltaN"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="adjDeltaE">
    <xsl:choose>
      <xsl:when test="$flag">
        <xsl:value-of select="$absDeltaN"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$absDeltaE"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- Compute the raw angle value -->
  <xsl:variable name="angle">
    <xsl:choose>
      <xsl:when test="$adjDeltaN &lt; 0.000001">
        <xsl:value-of select="0"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="arcTanAngle">
          <xsl:call-template name="ArcTan">
            <xsl:with-param name="tanVal" select="$adjDeltaE div $adjDeltaN"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:choose>
          <xsl:when test="$flag">
            <xsl:value-of select="$halfPi - $arcTanAngle"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$arcTanAngle"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- Assemble the raw angle value into an azimuth -->
  <xsl:variable name="azimuth">
    <xsl:choose>
      <xsl:when test="$deltaE &lt; 0">
        <xsl:choose>
          <xsl:when test="$deltaN &lt; 0">
            <xsl:value-of select="$Pi + $angle"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$Pi * 2 - $angle"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$deltaN &lt; 0">
            <xsl:value-of select="$Pi - $angle"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$angle"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- Return the azimuth value in decimal degrees -->
  <xsl:value-of select="$azimuth * 180 div $Pi"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- *************** Return the square root of a value ************** -->
<!-- **************************************************************** -->
<xsl:template name="Sqrt">
  <xsl:param name="num" select="0"/>       <!-- The number you want to find the square root of -->
  <xsl:param name="try" select="1"/>       <!-- The current 'try'.  This is used internally. -->
  <xsl:param name="iter" select="1"/>      <!-- The current iteration, checked against maxiter to limit loop count - used internally -->
  <xsl:param name="maxiter" select="40"/>  <!-- Set this up to insure against infinite loops - used internally -->

  <!-- This template uses Sir Isaac Newton's method of finding roots -->

  <xsl:choose>
    <xsl:when test="$try * $try = $num or $iter &gt; $maxiter">
      <xsl:value-of select="$try"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="Sqrt">
        <xsl:with-param name="num" select="$num"/>
        <xsl:with-param name="try" select="$try - (($try * $try - $num) div (2 * $try))"/>
        <xsl:with-param name="iter" select="$iter + 1"/>
        <xsl:with-param name="maxiter" select="$maxiter"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ******* Return radians angle less than Specificed Maximum ****** -->
<!-- **************************************************************** -->
<xsl:template name="AngleValueLessThanMax">
  <xsl:param name="InAngle"/>
  <xsl:param name="maxVal"/>
  <xsl:param name="incVal"/>

  <xsl:choose>
    <xsl:when test="$InAngle &gt; $maxVal">
      <xsl:variable name="NewAngle">
        <xsl:value-of select="$InAngle - $incVal"/>
      </xsl:variable>
      <xsl:call-template name="AngleValueLessThanMax">
        <xsl:with-param name="InAngle" select="$NewAngle"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:otherwise>
      <xsl:value-of select="$InAngle"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ****** Return radians angle greater than Specified Minimum ***** -->
<!-- **************************************************************** -->
<xsl:template name="AngleValueGreaterThanMin">
  <xsl:param name="InAngle"/>
  <xsl:param name="minVal"/>
  <xsl:param name="incVal"/>

  <xsl:choose>
    <xsl:when test="$InAngle &lt; $minVal">
      <xsl:variable name="NewAngle">
        <xsl:value-of select="$InAngle + $incVal"/>
      </xsl:variable>
      <xsl:call-template name="AngleValueGreaterThanMin">
        <xsl:with-param name="InAngle" select="$NewAngle"/>
      </xsl:call-template>
    </xsl:when>

    <xsl:otherwise>
      <xsl:value-of select="$InAngle"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ********* Return radians angle between Specified Limits ******** -->
<!-- **************************************************************** -->
<xsl:template name="RadianAngleBetweenLimits">
  <xsl:param name="AnAngle"/>
  <xsl:param name="minVal" select="0.0"/>
  <xsl:param name="maxVal" select="$Pi * 2.0"/>
  <xsl:param name="incVal" select="$Pi * 2.0"/>

  <xsl:variable name="Angle1">
    <xsl:call-template name="AngleValueLessThanMax">
      <xsl:with-param name="InAngle" select="$AnAngle"/>
      <xsl:with-param name="maxVal" select="$maxVal"/>
      <xsl:with-param name="incVal" select="$incVal"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="Angle2">
    <xsl:call-template name="AngleValueGreaterThanMin">
      <xsl:with-param name="InAngle" select="$Angle1"/>
      <xsl:with-param name="minVal" select="$minVal"/>
      <xsl:with-param name="incVal" select="$incVal"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:value-of select="$Angle2"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************ Return the sine of an angle in radians ************ -->
<!-- **************************************************************** -->
<xsl:template name="Sine">
  <xsl:param name="TheAngle"/>
  <xsl:variable name="NormalisedAngle">
    <xsl:call-template name="RadianAngleBetweenLimits">
      <xsl:with-param name="AnAngle" select="$TheAngle"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="TheSine">
    <xsl:call-template name="sineIter">
      <xsl:with-param name="pX2" select="$NormalisedAngle * $NormalisedAngle"/>
      <xsl:with-param name="pRslt" select="$NormalisedAngle"/>
      <xsl:with-param name="pElem" select="$NormalisedAngle"/>
      <xsl:with-param name="pN" select="1"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:value-of select="number($TheSine)"/>
</xsl:template>

<xsl:template name="sineIter">
  <xsl:param name="pX2"/>
  <xsl:param name="pRslt"/>
  <xsl:param name="pElem"/>
  <xsl:param name="pN"/>
  <xsl:param name="pEps" select="0.00000001"/>
  <xsl:variable name="vnextN" select="$pN+2"/>
  <xsl:variable name="vnewElem"  select="-$pElem*$pX2 div ($vnextN*($vnextN - 1))"/>
  <xsl:variable name="vnewResult" select="$pRslt + $vnewElem"/>
  <xsl:variable name="vdiffResult" select="$vnewResult - $pRslt"/>
  <xsl:choose>
    <xsl:when test="$vdiffResult > $pEps or $vdiffResult &lt; -$pEps">
      <xsl:call-template name="sineIter">
        <xsl:with-param name="pX2" select="$pX2"/>
        <xsl:with-param name="pRslt" select="$vnewResult"/>
        <xsl:with-param name="pElem" select="$vnewElem"/>
        <xsl:with-param name="pN" select="$vnextN"/>
        <xsl:with-param name="pEps" select="$pEps"/>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$vnewResult"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- *********** Return the Cosine of an angle in radians *********** -->
<!-- **************************************************************** -->
<xsl:template name="Cosine">
  <xsl:param name="TheAngle"/>

  <!-- Use the sine function after subtracting the angle from halfPi -->
  <xsl:call-template name="Sine">
    <xsl:with-param name="TheAngle" select="$halfPi - $TheAngle"/>
  </xsl:call-template>
</xsl:template>


<!-- **************************************************************** -->
<!-- *********** Return the Tangent of an angle in radians ********** -->
<!-- **************************************************************** -->
<xsl:template name="Tan">
  <xsl:param name="TheAngle"/>
  <xsl:param name="prec" select=".00000001"/>
  <xsl:param name="abortIfInvalid" select="1"/>

  <xsl:variable name="xDivHalfPi" select="floor($TheAngle div $halfPi)"/>
  <xsl:variable name="xHalfPiDiff" select="$TheAngle - $halfPi * $xDivHalfPi"/>

  <xsl:choose>  <!-- Check for a solution -->
    <xsl:when test="(-$prec &lt; $xHalfPiDiff) and
                    ($xHalfPiDiff &lt; $prec) and
                    ($xDivHalfPi mod 2 = 1)">
      <xsl:choose>
        <xsl:when test="$abortIfInvalid">
          <xsl:message terminate="yes">
            <xsl:value-of select="concat('Function error: tan() not defined for TheAngle =', $TheAngle)"/>
          </xsl:message>
        </xsl:when>

        <xsl:otherwise>Infinity</xsl:otherwise>
      </xsl:choose>
    </xsl:when>

    <!-- Compute the sine and cosine of the angle to get the tangent value -->
    <xsl:otherwise>
      <xsl:variable name="vSin">
        <xsl:call-template name="Sine">
          <xsl:with-param name="TheAngle" select="$TheAngle"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="vCos">
        <xsl:call-template name="Cosine">
          <xsl:with-param name="TheAngle" select="$TheAngle"/>
        </xsl:call-template>
      </xsl:variable>

      <xsl:value-of select="$vSin div $vCos"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ** Compute the arcTangent of value - angle returned in radians * -->
<!-- **************************************************************** -->
<xsl:template name="ArcTan">
  <xsl:param name="tanVal"/>
  <xsl:param name="prec" select="0.0000001"/>

  <!-- Solve the arctan value by using Newton's Method of solving the solution -->
  <!-- to an equation:                                                         -->
  <!--                               f(x )                                     -->
  <!--                                  n                                      -->
  <!--                 x     = x  -  ______                                    -->
  <!--                  n+1     n    f'(x )                                    -->
  <!--                                   n                                     -->
  <!--                                                                         -->
  <!-- The derivative of the tan function is:                                  -->
  <!--                                1                                        -->
  <!--                              ______                                     -->
  <!--                                    2                                    -->
  <!--                              cos(x)                                     -->
  <!--                                                                         -->
  <!-- This provides the following equation to be implemented for an arctan    -->
  <!-- function:                                                               -->
  <!--                                                          2              -->
  <!--                 x     = x  - (tan(x ) - tanVal) * cos(x )               -->
  <!--                  n+1     n         n                   n                -->
  <!--                                                                         -->

  <!-- If the tangent value is greater than 1 (45°) solve for the              -->
  <!-- complementary angle and then subtract it from 90° later                 -->

  <xsl:variable name="sign">
    <xsl:if test="$tanVal &lt; 0.0">-1</xsl:if>
    <xsl:if test="$tanVal &gt;= 0.0">1</xsl:if>
  </xsl:variable>
  <xsl:variable name="absTanVal" select="$tanVal * $sign"/>

  <xsl:variable name="tanValGreaterThan1">
    <xsl:if test="$absTanVal &gt; 1">1</xsl:if>
    <xsl:if test="not($absTanVal &gt; 1)">0</xsl:if>
  </xsl:variable>

  <xsl:variable name="tanValToUse">
    <xsl:choose>
      <xsl:when test="number($tanValGreaterThan1)">
        <xsl:value-of select="1.0 div $absTanVal"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$absTanVal"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="arcTanVal">
    <xsl:call-template name="RadianAngleBetweenLimits">  <!-- Return a normalised value between minus two Pi and two Pi -->
      <xsl:with-param name="minVal" select="-1 * $Pi * 2.0"/>
      <xsl:with-param name="AnAngle">
        <xsl:call-template name="arcTanIter">
          <xsl:with-param name="tanVal" select="$tanValToUse"/>
          <xsl:with-param name="prec" select="$prec"/>
          <xsl:with-param name="x" select="0"/>   <!-- Start at zero as first estimate -->
        </xsl:call-template>
      </xsl:with-param>
    </xsl:call-template>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="number($tanValGreaterThan1)">
      <xsl:value-of select="$sign * ($Pi div 2.0 - $arcTanVal)"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$sign * $arcTanVal"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template name="arcTanIter">
  <xsl:param name="tanVal"/>
  <xsl:param name="x" select="1"/>
  <xsl:param name="iterCount" select="1"/>
  <xsl:param name="prec" select="0.0000001"/>
  <xsl:variable name="maxIter" select="100"/>

  <xsl:variable name="tanX">
    <xsl:call-template name="Tan">
      <xsl:with-param name="TheAngle" select="$x"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="cosX">
    <xsl:call-template name="Cosine">
      <xsl:with-param name="TheAngle" select="$x"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="xNew" select="$x - ($tanX - $tanVal) * $cosX * $cosX"/>

  <xsl:variable name="absDiff" select="concat(substring('-',2 - (($xNew - $x) &lt; 0)), '1') * ($xNew - $x)"/>

  <xsl:choose>
    <xsl:when test="($absDiff &lt; $prec) or ($iterCount &gt; $maxIter)">
      <xsl:value-of select="$xNew"/>  <!-- We have a solution or have run out of iterations -->
    </xsl:when>
    <xsl:otherwise>
      <xsl:call-template name="arcTanIter">
        <xsl:with-param name="tanVal" select="$tanVal"/>
        <xsl:with-param name="x" select="$xNew"/>
        <xsl:with-param name="iterCount" select="$iterCount + 1"/>
      </xsl:call-template>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template>


<!-- **************************************************************** -->
<!-- *********** Compute ArcSine value using an expansion *********** -->
<!-- **************************************************************** -->
<xsl:template name="ArcSin">
  <xsl:param name="sinVal"/>

  <xsl:choose>
    <xsl:when test="($sinVal &gt;= -1.0) and ($sinVal &lt;= 1.0)">  <!-- We can compute a solution -->
      <xsl:variable name="valToPowerOf3" select="$sinVal * $sinVal * $sinVal"/>
      <xsl:variable name="valToPowerOf5" select="$valToPowerOf3 * $sinVal * $sinVal"/>
      <xsl:variable name="valToPowerOf7" select="$valToPowerOf5 * $sinVal * $sinVal"/>
      <xsl:variable name="valToPowerOf9" select="$valToPowerOf7 * $sinVal * $sinVal"/>
      <xsl:variable name="valToPowerOf11" select="$valToPowerOf9 * $sinVal * $sinVal"/>
      <xsl:variable name="valToPowerOf13" select="$valToPowerOf11 * $sinVal * $sinVal"/>
      <xsl:variable name="valToPowerOf15" select="$valToPowerOf13 * $sinVal * $sinVal"/>
      <xsl:variable name="valToPowerOf17" select="$valToPowerOf15 * $sinVal * $sinVal"/>
      <xsl:variable name="valToPowerOf19" select="$valToPowerOf17 * $sinVal * $sinVal"/>

      <xsl:value-of select="$sinVal + $valToPowerOf3 div 6.0
                                    + 3.0 * $valToPowerOf5 div 40.0
                                    + 5.0 * $valToPowerOf7 div 112.0
                                    + 35.0 * $valToPowerOf9 div 1152.0
                                    + 63.0 * $valToPowerOf11 div 2816
                                    + 231.0 * $valToPowerOf13 div 13312
                                    + 143.0 * $valToPowerOf15 div 10240
                                    + 6435.0 * $valToPowerOf17 div 557056.0
                                    + 12155.0 * $valToPowerOf19 div 1245184.0"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="''"/>  <!-- Return null value -->
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


</xsl:stylesheet>