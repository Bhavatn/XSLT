<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"    
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt">

<!-- (c) 2013, Trimble Navigation Limited. All rights reserved.                                -->
<!-- Permission is hereby granted to use, copy, modify, or distribute this style sheet for any -->
<!-- purpose and without fee, provided that the above copyright notice appears in all copies   -->
<!-- and that both the copyright notice and the limited warranty and restricted rights notice  -->
<!-- below appear in all supporting documentation.                                             -->

<!-- TRIMBLE NAVIGATION LIMITED PROVIDES THIS STYLE SHEET "AS IS" AND WITH ALL FAULTS.         -->
<!-- TRIMBLE NAVIGATION LIMITED SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY -->
<!-- OR FITNESS FOR A PARTICULAR USE. TRIMBLE NAVIGATION LIMITED DOES NOT WARRANT THAT THE     -->
<!-- OPERATION OF THIS STYLE SHEET WILL BE UNINTERRUPTED OR ERROR FREE.                        -->

<xsl:output method="html" omit-xml-declaration="no"  encoding="utf-8"/>

<!-- Set the numeric display details i.e. decimal point, thousands separator etc -->
<xsl:variable name="DecPt" select="'.'"/>    <!-- Change as appropriate for US/European -->
<xsl:variable name="GroupSep" select="','"/> <!-- Change as appropriate for US/European -->
<!-- Also change decimal-separator & grouping-separator in decimal-format below 
     as appropriate for US/European output -->
<xsl:decimal-format name="Standard" 
                    decimal-separator="."
                    grouping-separator=","
                    infinity="Infinity"
                    minus-sign="-"
                    NaN="?"
                    percent="%"
                    per-mille="&#2030;"
                    zero-digit="0" 
                    digit="#" 
                    pattern-separator=";" />

<xsl:variable name="DecPl0" select="'#0'"/>
<xsl:variable name="DecPl1" select="concat('#0', $DecPt, '0')"/>
<xsl:variable name="DecPl2" select="concat('#0', $DecPt, '00')"/>
<xsl:variable name="DecPl3" select="concat('#0', $DecPt, '000')"/>
<xsl:variable name="DecPl4" select="concat('#0', $DecPt, '0000')"/>
<xsl:variable name="DecPl5" select="concat('#0', $DecPt, '00000')"/>
<xsl:variable name="DecPl6" select="concat('#0', $DecPt, '000000')"/>
<xsl:variable name="DecPl8" select="concat('#0', $DecPt, '00000000')"/>

<xsl:variable name="DegreesSymbol" select="'&#0176;'"/>
<xsl:variable name="MinutesSymbol"><xsl:text>'</xsl:text></xsl:variable>
<xsl:variable name="SecondsSymbol" select="'&quot;'"/>

<xsl:variable name="fileExt" select="'htm'"/>

<xsl:variable name="useChainageTerminology">false</xsl:variable>
<xsl:variable name="useRailTerminology">false</xsl:variable>

<!-- User variable definitions - Appropriate fields are displayed on the       -->
<!-- Survey Controller screen to allow the user to enter specific values       -->
<!-- which can then be used within the style sheet definition to control the   -->
<!-- output data.                                                              -->
<!--                                                                           -->
<!-- All user variables must be identified by a variable element definition    -->
<!-- named starting with 'userField' (case sensitive) followed by one or more  -->
<!-- characters uniquely identifying the user variable definition.             -->
<!--                                                                           -->
<!-- The text within the 'select' field for the user variable description      -->
<!-- references the actual user variable and uses the '|' character to         -->
<!-- separate the definition details into separate fields as follows:          -->
<!-- For all user variables the first field must be the name of the user       -->
<!-- variable itself (this is case sensitive) and the second field is the      -->
<!-- prompt that will appear on the Survey Controller screen.                  -->
<!-- The third field defines the variable type - there are four possible       -->
<!-- variable types: Double, Integer, String and StringMenu.  These variable   -->
<!-- type references are not case sensitive.                                   -->
<!-- The fields that follow the variable type change according to the type of  -->
<!-- variable as follow:                                                       -->
<!-- Double and Integer: Fourth field = optional minimum value                 -->
<!--                     Fifth field = optional maximum value                  -->
<!--   These minimum and maximum values are used by the Survey Controller for  -->
<!--   entry validation.                                                       -->
<!-- String: No further fields are needed or used.                             -->
<!-- StringMenu: Fourth field = number of menu items                           -->
<!--             Remaining fields are the actual menu items - the number of    -->
<!--             items provided must equal the specified number of menu items. -->
<!--                                                                           -->
<!-- The style sheet must also define the variable itself, named according to  -->
<!-- the definition.  The value within the 'select' field will be displayed in -->
<!-- the Survey Controller as the default value for the item.                  -->

<xsl:variable name="userField1" select="'outputOrder|Output order|stringMenu|2|As observed|Grouped by stakeout type'"/>
<xsl:variable name="outputOrder" select="'As observed'"/>
<xsl:variable name="userField2" select="'startDate|Optional start date for report (yyyy-mm-dd)|string'"/>
<xsl:variable name="startDate" select="''"/>
<xsl:variable name="userField3" select="'endDate|Optional end date for report (yyyy-mm-dd)|string'"/>
<xsl:variable name="endDate" select="''"/>
<xsl:variable name="userField4" select="'includeCatchVertDists|Include hinge and CL vert dists for catch pts|stringMenu|2|Yes|No'"/>
<xsl:variable name="includeCatchVertDists" select="'Yes'"/>
<xsl:variable name="userField5" select="'jobDesc|Job description|string'"/>
<xsl:variable name="jobDesc" select="''"/>

<!-- **************************************************************** -->
<!-- Set global variables from the Environment section of JobXML file -->
<!-- **************************************************************** -->
<xsl:variable name="DistUnit"   select="/JOBFile/Environment/DisplaySettings/DistanceUnits" />
<xsl:variable name="AngleUnit"  select="/JOBFile/Environment/DisplaySettings/AngleUnits" />
<xsl:variable name="CoordOrder" select="/JOBFile/Environment/DisplaySettings/CoordinateOrder" />
<xsl:variable name="TempUnit"   select="/JOBFile/Environment/DisplaySettings/TemperatureUnits" />
<xsl:variable name="PressUnit"  select="/JOBFile/Environment/DisplaySettings/PressureUnits" />

<!-- Setup conversion factor for coordinate and distance values -->
<!-- Dist/coord values in JobXML file are always in metres -->
<xsl:variable name="DistConvFactor">
  <xsl:choose>
    <xsl:when test="$DistUnit='Metres'">1.0</xsl:when>
    <xsl:when test="$DistUnit='InternationalFeet'">3.280839895</xsl:when>
    <xsl:when test="$DistUnit='USSurveyFeet'">3.2808333333357</xsl:when>
    <xsl:otherwise>1.0</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<!-- Setup conversion factor for angular values -->
<!-- Angular values in JobXML file are always in decimal degrees -->
<xsl:variable name="AngleConvFactor">
  <xsl:choose>
    <xsl:when test="$AngleUnit='DMSDegrees'">1.0</xsl:when>
    <xsl:when test="$AngleUnit='Gons'">1.111111111111</xsl:when>
    <xsl:when test="$AngleUnit='Mils'">17.77777777777</xsl:when>
    <xsl:otherwise>1.0</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<!-- Setup boolean variable for coordinate order -->
<xsl:variable name="NECoords">
  <xsl:choose>
    <xsl:when test="$CoordOrder='North-East-Elevation'">true</xsl:when>
    <xsl:when test="$CoordOrder='X-Y-Z'">true</xsl:when>
    <xsl:otherwise>false</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<!-- Setup conversion factor for pressure values -->
<!-- Pressure values in JobXML file are always in millibars (hPa) -->
<xsl:variable name="PressConvFactor">
  <xsl:choose>
    <xsl:when test="$PressUnit='MilliBar'">1.0</xsl:when>
    <xsl:when test="$PressUnit='InchHg'">0.029529921</xsl:when>
    <xsl:when test="$PressUnit='mmHg'">0.75006</xsl:when>
    <xsl:otherwise>1.0</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<xsl:variable name="stnFormatStyle">
  <xsl:value-of select="/JOBFile/Environment/DisplaySettings/StationingFormat"/>
</xsl:variable>

<xsl:variable name="product">
  <xsl:choose>
    <xsl:when test="JOBFile/@product"><xsl:value-of select="JOBFile/@product"/></xsl:when>
    <xsl:otherwise>Trimble Survey Controller</xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<xsl:variable name="version">
  <xsl:choose>
    <xsl:when test="JOBFile/@productVersion"><xsl:value-of select="JOBFile/@productVersion"/></xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="format-number(JOBFile/@version div 100, $DecPl2, 'Standard')"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<xsl:variable name="schemaVersion">
  <xsl:choose>
    <xsl:when test="JOBFile/@productVersion"><xsl:value-of select="JOBFile/@version"/></xsl:when>
    <xsl:otherwise>3.0</xsl:otherwise>  <!-- JobXML file prior to schema definition - set to 3.0 (prior to initial v4.0 schema) -->
  </xsl:choose>
</xsl:variable>

<xsl:variable name="reportStartDate">
  <xsl:choose>
    <xsl:when test="$startDate = ''">
      <xsl:value-of select="substring-before(/JOBFile/FieldBook/PointRecord[(Deleted = 'false') and Stakeout][1]/@TimeStamp, 'T')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$startDate"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<xsl:variable name="reportEndDate">
  <xsl:choose>
    <xsl:when test="$endDate = ''">
      <xsl:value-of select="substring-before(/JOBFile/FieldBook/PointRecord[(Deleted = 'false') and Stakeout][last()]/@TimeStamp, 'T')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$endDate"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:variable>

<xsl:variable name="startJulianDay">
  <xsl:call-template name="TimeStampToJulianDay">
    <xsl:with-param name="timeStamp" select="concat($reportStartDate, 'T00:00:00')"/>
  </xsl:call-template>
</xsl:variable>

<xsl:variable name="endJulianDay">
  <xsl:call-template name="TimeStampToJulianDay">
    <xsl:with-param name="timeStamp" select="concat($reportEndDate, 'T00:00:00')"/>
  </xsl:call-template>
</xsl:variable>


<!-- **************************************************************** -->
<!-- ************************** Main Loop *************************** -->
<!-- **************************************************************** -->
<xsl:template match="/" >
  <html>

  <title>Stakeout Report</title>
  <h2>Stakeout Report</h2>

  <!-- Set the font size for use in tables -->
  <style type="text/css">
    html { font-family: Arial }
    body, table, td, th
    {
      font-size:13px;
    }
    th.blackTitleLine {background-color: black; color: white}
    th.silverTitleLine {background-color: silver}
  </style>

  <head>
  </head>

  <body>
  <table border="0" width="100%" cellpadding="5">
    <tr>
      <td align="left" width="30%">Job name:</td>
      <td align="left" width="20%"><xsl:value-of select="JOBFile/@jobName"/></td>
      <td align="left" width="30%"><xsl:value-of select="$product"/> version:</td>
      <td align="left" width="20%"><xsl:value-of select="$version"/></td>
    </tr>
    <tr>
      <td align="left" width="30%">Creation date:</td>
      <td align="left" width="20%"><xsl:value-of select="substring-before(JOBFile/@TimeStamp, 'T')"/></td>
      <td align="left" width="30%">Distance/Coord units:</td>
      <td align="left" width="20%">
        <xsl:choose>
          <xsl:when test="$DistUnit = 'InternationalFeet'">International feet</xsl:when>
          <xsl:when test="$DistUnit = 'USSurveyFeet'">US survey feet</xsl:when>
          <xsl:otherwise>Meters</xsl:otherwise>
        </xsl:choose>
      </td>
    </tr>
    <tr>
      <td align="left" width="30%">Start date for reported points:</td>
      <td align="left" width="20%">
        <xsl:call-template name="FormattedDate">
          <xsl:with-param name="timeStamp" select="$reportStartDate"/>
        </xsl:call-template>
      </td>
      <td align="left" width="30%">End date for reported points:</td>
      <td align="left" width="20%">
        <xsl:call-template name="FormattedDate">
          <xsl:with-param name="timeStamp" select="$reportEndDate"/>
        </xsl:call-template>
      </td>
    </tr>
  </table>

  <xsl:if test="$jobDesc != ''">
    <table border="0" width="100%" cellpadding="5">
      <tr>
        <td align="left" width="30%">Job description:</td>
        <td align="left" width="70%"><xsl:value-of select="$jobDesc"/></td>
      </tr>
    </table>
  </xsl:if>

  <xsl:call-template name="SeparatingLine"/>

  <!-- Select the FieldBook node to process -->
  <xsl:apply-templates select="JOBFile/FieldBook" />

  </body>
  </html>
</xsl:template>


<!-- **************************************************************** -->
<!-- ***************** FieldBook Node Processing ******************** -->
<!-- **************************************************************** -->
<xsl:template match="FieldBook">
  <!-- Process all the undeleted point records under the FieldBook node that
       have Stakeout elements in the order encountered -->
  <xsl:variable name="stakeoutRecords">
    <xsl:choose>
      <xsl:when test="$outputOrder = 'As observed'">
        <xsl:for-each select="PointRecord[(Deleted = 'false') and Stakeout]">
          <xsl:variable name="validDate">
            <xsl:call-template name="InDateRange">
              <xsl:with-param name="date" select="substring-before(@TimeStamp, 'T')"/>
            </xsl:call-template>
          </xsl:variable>
          <xsl:if test="$validDate = 'true'">
            <xsl:copy>
              <xsl:copy-of select="* | @*"/>
            </xsl:copy>
          </xsl:if>
        </xsl:for-each>
      </xsl:when>
      
      <xsl:otherwise>
        <xsl:for-each select="PointRecord[(Deleted = 'false') and Stakeout]">
          <xsl:sort data-type="text" order="ascending" select="name(Stakeout/*[1])"/>     <!-- Sort by stakeout type -->
          <xsl:sort data-type="text" order="ascending" select="Stakeout/*[1]/Name"/>      <!-- Sort by line/road name -->
          <xsl:sort data-type="number" order="ascending" select="Stakeout/*[1]/Station"/> <!-- Sort by station -->
          <xsl:variable name="validDate">
            <xsl:call-template name="InDateRange">
              <xsl:with-param name="date" select="substring-before(@TimeStamp, 'T')"/>
            </xsl:call-template>
          </xsl:variable>
          <xsl:if test="$validDate = 'true'">
            <xsl:copy>
              <xsl:copy-of select="* | @*"/>
            </xsl:copy>
          </xsl:if>
        </xsl:for-each>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- Write out the initial date reference if appropriate -->
  <xsl:if test="$outputOrder = 'As observed'">
    <xsl:for-each select="msxsl:node-set($stakeoutRecords)/PointRecord[(Deleted = 'false') and Stakeout][1]">
      <xsl:call-template name="OutputDateTable">
        <xsl:with-param name="skipEndTable" select="'true'"/>
      </xsl:call-template>
    </xsl:for-each>
  </xsl:if>

  <xsl:apply-templates select="msxsl:node-set($stakeoutRecords)/PointRecord"/>
  <!-- End the last table -->
  <xsl:call-template name="EndTable"/>

</xsl:template>


<!-- **************************************************************** -->
<!-- ******************** PointRecord Output ************************ -->
<!-- **************************************************************** -->
<xsl:template match="PointRecord">

  <xsl:choose>
    <xsl:when test="Stakeout/PointDesign">
      <xsl:call-template name="PointStakeoutDeltas"/>
    </xsl:when>

    <xsl:when test="Stakeout/LineDesign">
      <xsl:call-template name="LineStakeoutDeltas"/>
    </xsl:when>
    
    <xsl:when test="Stakeout/ArcDesign">
      <xsl:call-template name="ArcStakeoutDeltas"/>
    </xsl:when>
    
    <xsl:when test="Stakeout/AlignmentDesign">
      <xsl:call-template name="AlignmentStakeoutDeltas"/>
    </xsl:when>

    <xsl:when test="Stakeout/DTMDesign">
      <xsl:call-template name="DTMStakeoutDeltas"/>
    </xsl:when>

    <xsl:when test="Stakeout/RoadDesign">
      <xsl:call-template name="RoadStakeoutDeltas"/>
    </xsl:when>
  </xsl:choose>

</xsl:template>


<!-- **************************************************************** -->
<!-- ************ Point Stakeout Deltas Details Output ************** -->
<!-- **************************************************************** -->
<xsl:template name="PointStakeoutDeltas">

  <xsl:variable name="outputDate">
    <xsl:call-template name="OutputDateIsRequired"/>
  </xsl:variable>

  <xsl:if test="$outputDate = 'true'">
    <xsl:call-template name="OutputDateTable"/>
  </xsl:if>

  <xsl:if test="(position() = 1) or not(preceding-sibling::*[1]/Stakeout/PointDesign) or ($outputDate = 'true')">
    <!-- End any existing table -->
    <xsl:if test="(position() &gt; 1) and ($outputDate != 'true')">
      <xsl:call-template name="EndTable"/>
    </xsl:if>

    <xsl:call-template name="StartTable">
      <xsl:with-param name="caption" select="'Point Stakeout'"/>
      <xsl:with-param name="includeBorders" select="'Yes'"/>
      <xsl:with-param name="tableWidth" select="100"/>
    </xsl:call-template>
    <!-- Output table column headings -->
    <tr>
      <th class="silverTitleLine" align="center" width="14%">Design Name</th>
      <th class="silverTitleLine" align="center" width="18%">Code</th>
      <xsl:choose>
        <xsl:when test="$NECoords = 'true'">
          <th class="silverTitleLine" align="center" width="12%">Design N</th>
          <th class="silverTitleLine" align="center" width="12%">Design E</th>
        </xsl:when>
        <xsl:otherwise>
          <th class="silverTitleLine" align="center" width="12%">Design E</th>
          <th class="silverTitleLine" align="center" width="12%">Design N</th>
        </xsl:otherwise>
      </xsl:choose>
      <th class="silverTitleLine" align="center" width="10%">Design Z</th>
      <th class="silverTitleLine" align="center" width="10%">Staked Z</th>
      <th class="silverTitleLine" align="center" width="10%">Cut/Fill</th>
      <xsl:choose>
        <xsl:when test="$NECoords = 'true'">
          <th class="silverTitleLine" align="center" width="7%">ΔN</th>
          <th class="silverTitleLine" align="center" width="7%">ΔE</th>
        </xsl:when>
        <xsl:otherwise>
          <th class="silverTitleLine" align="center" width="7%">ΔE</th>
          <th class="silverTitleLine" align="center" width="7%">ΔN</th>
        </xsl:otherwise>
      </xsl:choose>
    </tr>
  </xsl:if>

  <!-- Output the point stake details -->
  <tr>
    <td align="left"><xsl:value-of select="Stakeout/PointDesign/Name"/></td>
    <td align="left"><xsl:value-of select="Code"/></td>
    <xsl:choose>
      <xsl:when test="$NECoords = 'true'">
        <td align="right"><xsl:value-of select="format-number((ComputedGrid/North + Stakeout/GridDeltas/DeltaNorth) * $DistConvFactor, $DecPl3, 'Standard')"/></td>
        <td align="right"><xsl:value-of select="format-number((ComputedGrid/East + Stakeout/GridDeltas/DeltaEast) * $DistConvFactor, $DecPl3, 'Standard')"/></td>
      </xsl:when>
      <xsl:otherwise>
        <td align="right"><xsl:value-of select="format-number((ComputedGrid/East + Stakeout/GridDeltas/DeltaEast) * $DistConvFactor, $DecPl3, 'Standard')"/></td>
        <td align="right"><xsl:value-of select="format-number((ComputedGrid/North + Stakeout/GridDeltas/DeltaNorth) * $DistConvFactor, $DecPl3, 'Standard')"/></td>
      </xsl:otherwise>
    </xsl:choose>
    <td align="right">
      <xsl:choose>
        <xsl:when test="string(number(Stakeout/PointDesign/DesignElevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/PointDesign/DesignElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="deltaElev">
            <xsl:choose>
              <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
                <xsl:value-of select="Stakeout/GridDeltas/DeltaElevation"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="Stakeout/LinearDeltas/DeltaElevation"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:value-of select="format-number((ComputedGrid/Elevation + $deltaElev) * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number(ComputedGrid/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <xsl:choose>
      <xsl:when test="$NECoords = 'true'">
        <td align="right"><xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaNorth * $DistConvFactor, $DecPl3, 'Standard')"/></td>
        <td align="right"><xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaEast * $DistConvFactor, $DecPl3, 'Standard')"/></td>
      </xsl:when>
      <xsl:otherwise>
        <td align="right"><xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaEast * $DistConvFactor, $DecPl3, 'Standard')"/></td>
        <td align="right"><xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaNorth * $DistConvFactor, $DecPl3, 'Standard')"/></td>
      </xsl:otherwise>
    </xsl:choose>
  </tr>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************* Line Stakeout Deltas Details Output ************** -->
<!-- **************************************************************** -->
<xsl:template name="LineStakeoutDeltas">

  <xsl:variable name="outputDate">
    <xsl:call-template name="OutputDateIsRequired"/>
  </xsl:variable>

  <xsl:if test="$outputDate = 'true'">
    <xsl:call-template name="OutputDateTable"/>
  </xsl:if>

  <xsl:if test="(position() = 1) or not(preceding-sibling::*[1]/Stakeout/LineDesign) or ($outputDate = 'true') or
                (preceding-sibling::*[1]/Stakeout/LineDesign and (preceding-sibling::*[1]/Stakeout/LineDesign/Name != Stakeout/LineDesign/Name))">
    <!-- End any existing table -->
    <xsl:if test="(position() &gt; 1) and ($outputDate != 'true')">
      <xsl:call-template name="EndTable"/>
    </xsl:if>

    <xsl:call-template name="StartTable">
      <xsl:with-param name="caption" select="concat('Line Stakeout: ', Stakeout/LineDesign/Name)"/>
      <xsl:with-param name="includeBorders" select="'Yes'"/>
      <xsl:with-param name="tableWidth" select="100"/>
    </xsl:call-template>
    <!-- Output table column headings -->
    <tr>
      <th class="silverTitleLine" align="center" width="10%">Point Name</th>
      <th class="silverTitleLine" align="center" width="15%">Code</th>
      <th class="silverTitleLine" align="center" width="15%">Line Name</th>
      <th class="silverTitleLine" align="center" width="9%">
        <xsl:choose>
          <xsl:when test="$useChainageTerminology = 'true'">Chainage</xsl:when>
          <xsl:otherwise>Station</xsl:otherwise>
        </xsl:choose>
      </th>
      <th class="silverTitleLine" align="center" width="9%">Offset</th>
      <th class="silverTitleLine" align="center" width="9%">Design Z</th>
      <th class="silverTitleLine" align="center" width="9%">Staked Z</th>
      <th class="silverTitleLine" align="center" width="8%">Cut/Fill</th>
      <th class="silverTitleLine" align="center" width="8%">
        <xsl:choose>
          <xsl:when test="$useChainageTerminology = 'true'">Δ Chainage</xsl:when>
          <xsl:otherwise>Δ Station</xsl:otherwise>
        </xsl:choose>
      </th>
      <th class="silverTitleLine" align="center" width="8%">Δ Offset</th>
    </tr>
  </xsl:if>

  <!-- Output the line stake details -->
  <xsl:variable name="stnVal">
    <xsl:call-template name="FormatStationVal">
      <xsl:with-param name="stationVal" select="Stakeout/LineDesign/Station"/>
      <xsl:with-param name="definedFmt" select="$stnFormatStyle"/>
    </xsl:call-template>
  </xsl:variable>

  <tr>
    <td align="left"><xsl:value-of select="Name"/></td>
    <td align="left"><xsl:value-of select="Code"/></td>
    <td align="left"><xsl:value-of select="Stakeout/LineDesign/Name"/></td>
    <td align="right"><xsl:value-of select="$stnVal"/></td>
    <td align="right">
      <xsl:variable name="offset">
        <xsl:choose>
          <xsl:when test="string(number(Stakeout/LineDesign/Offset)) = 'NaN'">
            <xsl:if test="(Stakeout/LineDesign/StakeoutMethod = 'ToTheLine') or
                          (Stakeout/LineDesign/StakeoutMethod = 'PointOnLine')">0</xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="Stakeout/LineDesign/Offset"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:value-of select="format-number($offset * $DistConvFactor, $DecPl3, 'Standard')"/>
    </td>
    <td align="right">
      <xsl:choose>
        <xsl:when test="string(number(Stakeout/LineDesign/Elevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/LineDesign/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="deltaElev">
            <xsl:choose>
              <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
                <xsl:value-of select="Stakeout/GridDeltas/DeltaElevation"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="Stakeout/LinearDeltas/DeltaElevation"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:value-of select="format-number((ComputedGrid/Elevation + $deltaElev) * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number(ComputedGrid/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right">
      <xsl:choose>   <!-- Use the DeltaElevation from the GridDeltas element if possible -->
        <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaStation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaOffset * $DistConvFactor, $DecPl3, 'Standard')"/></td>
  </tr>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************* Arc Stakeout Deltas Details Output *************** -->
<!-- **************************************************************** -->
<xsl:template name="ArcStakeoutDeltas">

  <xsl:variable name="outputDate">
    <xsl:call-template name="OutputDateIsRequired"/>
  </xsl:variable>

  <xsl:if test="$outputDate = 'true'">
    <xsl:call-template name="OutputDateTable"/>
  </xsl:if>

  <xsl:if test="(position() = 1) or not(preceding-sibling::*[1]/Stakeout/ArcDesign) or ($outputDate = 'true') or
                (preceding-sibling::*[1]/Stakeout/ArcDesign and (preceding-sibling::*[1]/Stakeout/ArcDesign/Name != Stakeout/ArcDesign/Name))">
    <!-- End any existing table -->
    <xsl:if test="(position() &gt; 1) and ($outputDate != 'true')">
      <xsl:call-template name="EndTable"/>
    </xsl:if>

    <xsl:call-template name="StartTable">
      <xsl:with-param name="caption" select="concat('Arc Stakeout: ', Stakeout/ArcDesign/Name)"/>
      <xsl:with-param name="includeBorders" select="'Yes'"/>
      <xsl:with-param name="tableWidth" select="100"/>
    </xsl:call-template>
    <!-- Output table column headings -->
    <tr>
      <th class="silverTitleLine" align="center" width="10%">Point Name</th>
      <th class="silverTitleLine" align="center" width="15%">Code</th>
      <th class="silverTitleLine" align="center" width="15%">Arc Name</th>
      <th class="silverTitleLine" align="center" width="9%">
        <xsl:choose>
          <xsl:when test="$useChainageTerminology = 'true'">Chainage</xsl:when>
          <xsl:otherwise>Station</xsl:otherwise>
        </xsl:choose>
      </th>
      <th class="silverTitleLine" align="center" width="9%">Offset</th>
      <th class="silverTitleLine" align="center" width="9%">Design Z</th>
      <th class="silverTitleLine" align="center" width="9%">Staked Z</th>
      <th class="silverTitleLine" align="center" width="8%">Cut/Fill</th>
      <th class="silverTitleLine" align="center" width="8%">
        <xsl:choose>
          <xsl:when test="$useChainageTerminology = 'true'">Δ Chainage</xsl:when>
          <xsl:otherwise>Δ Station</xsl:otherwise>
        </xsl:choose>
      </th>
      <th class="silverTitleLine" align="center" width="8%">Δ Offset</th>
    </tr>
  </xsl:if>

  <!-- Output the arc stake details -->
  <xsl:variable name="stnVal">
    <xsl:call-template name="FormatStationVal">
      <xsl:with-param name="stationVal" select="Stakeout/ArcDesign/Station"/>
      <xsl:with-param name="definedFmt" select="$stnFormatStyle"/>
    </xsl:call-template>
  </xsl:variable>

  <tr>
    <td align="left"><xsl:value-of select="Name"/></td>
    <td align="left"><xsl:value-of select="Code"/></td>
    <td align="left"><xsl:value-of select="Stakeout/ArcDesign/Name"/></td>
    <td align="right"><xsl:value-of select="$stnVal"/></td>
    <td align="right">
      <xsl:variable name="offset">
        <xsl:choose>
          <xsl:when test="string(number(Stakeout/ArcDesign/Offset)) = 'NaN'">
            <xsl:if test="(Stakeout/ArcDesign/StakeoutMethod = 'ToTheArc') or
                          (Stakeout/ArcDesign/StakeoutMethod = 'PointOnArc')">0</xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="Stakeout/ArcDesign/Offset"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:value-of select="format-number($offset * $DistConvFactor, $DecPl3, 'Standard')"/>
    </td>
    <td align="right">
      <xsl:choose>
        <xsl:when test="string(number(Stakeout/ArcDesign/Elevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/ArcDesign/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="deltaElev">
            <xsl:choose>
              <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
                <xsl:value-of select="Stakeout/GridDeltas/DeltaElevation"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="Stakeout/LinearDeltas/DeltaElevation"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:value-of select="format-number((ComputedGrid/Elevation + $deltaElev) * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number(ComputedGrid/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right">
      <xsl:choose>   <!-- Use the DeltaElevation from the GridDeltas element if possible -->
        <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaStation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaOffset * $DistConvFactor, $DecPl3, 'Standard')"/></td>
  </tr>

</xsl:template>


<!-- **************************************************************** -->
<!-- *********** Alignment Stakeout Deltas Details Output *********** -->
<!-- **************************************************************** -->
<xsl:template name="AlignmentStakeoutDeltas">

  <xsl:variable name="outputDate">
    <xsl:call-template name="OutputDateIsRequired"/>
  </xsl:variable>

  <xsl:if test="$outputDate = 'true'">
    <xsl:call-template name="OutputDateTable"/>
  </xsl:if>

  <xsl:if test="(position() = 1) or not(preceding-sibling::*[1]/Stakeout/AlignmentDesign) or ($outputDate = 'true') or
                (preceding-sibling::*[1]/Stakeout/AlignmentDesign and (preceding-sibling::*[1]/Stakeout/AlignmentDesign/Name != Stakeout/AlignmentDesign/Name))">
    <!-- End any existing table -->
    <xsl:if test="(position() &gt; 1) and ($outputDate != 'true')">
      <xsl:call-template name="EndTable"/>
    </xsl:if>

    <xsl:call-template name="StartTable">
      <xsl:with-param name="caption" select="concat('Alignment Stakeout: ', Stakeout/AlignmentDesign/Name)"/>
      <xsl:with-param name="includeBorders" select="'Yes'"/>
      <xsl:with-param name="tableWidth" select="100"/>
    </xsl:call-template>
    <!-- Output table column headings -->
    <tr>
      <th class="silverTitleLine" align="center" width="10%">Point Name</th>
      <th class="silverTitleLine" align="center" width="15%">Code</th>
      <th class="silverTitleLine" align="center" width="15%">Alignment Name</th>
      <th class="silverTitleLine" align="center" width="9%">
        <xsl:choose>
          <xsl:when test="$useChainageTerminology = 'true'">Chainage</xsl:when>
          <xsl:otherwise>Station</xsl:otherwise>
        </xsl:choose>
      </th>
      <th class="silverTitleLine" align="center" width="9%">Offset</th>
      <th class="silverTitleLine" align="center" width="9%">Design Z</th>
      <th class="silverTitleLine" align="center" width="9%">Staked Z</th>
      <th class="silverTitleLine" align="center" width="8%">Cut/Fill</th>
      <th class="silverTitleLine" align="center" width="8%">
        <xsl:choose>
          <xsl:when test="$useChainageTerminology = 'true'">Δ Chainage</xsl:when>
          <xsl:otherwise>Δ Station</xsl:otherwise>
        </xsl:choose>
      </th>
      <th class="silverTitleLine" align="center" width="8%">Δ Offset</th>
    </tr>
  </xsl:if>

  <!-- Output the line stake details -->
  <xsl:variable name="stnVal">
    <xsl:call-template name="FormatStationVal">
      <xsl:with-param name="stationVal" select="Stakeout/AlignmentDesign/Station"/>
      <xsl:with-param name="definedFmt" select="$stnFormatStyle"/>
    </xsl:call-template>
  </xsl:variable>

  <tr>
    <td align="left"><xsl:value-of select="Name"/></td>
    <td align="left"><xsl:value-of select="Code"/></td>
    <td align="left"><xsl:value-of select="Stakeout/AlignmentDesign/Name"/></td>
    <td align="right"><xsl:value-of select="$stnVal"/></td>
    <td align="right">
      <xsl:variable name="offset">
        <xsl:choose>
          <xsl:when test="string(number(Stakeout/AlignmentDesign/Offset)) = 'NaN'">
            <xsl:if test="Stakeout/AlignmentDesign/StakeoutMethod = 'StationOnAlignment'">0</xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="Stakeout/AlignmentDesign/Offset"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:value-of select="format-number($offset * $DistConvFactor, $DecPl3, 'Standard')"/>
    </td>
    <td align="right">
      <xsl:choose>
        <xsl:when test="string(number(Stakeout/AlignmentDesign/Elevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/AlignmentDesign/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="deltaElev">
            <xsl:choose>
              <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
                <xsl:value-of select="Stakeout/GridDeltas/DeltaElevation"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="Stakeout/LinearDeltas/DeltaElevation"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:value-of select="format-number((ComputedGrid/Elevation + $deltaElev) * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number(ComputedGrid/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right">
      <xsl:choose>   <!-- Use the DeltaElevation from the GridDeltas element if possible -->
        <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaStation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaOffset * $DistConvFactor, $DecPl3, 'Standard')"/></td>
  </tr>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************* DTM Stakeout Deltas Details Output *************** -->
<!-- **************************************************************** -->
<xsl:template name="DTMStakeoutDeltas">

  <xsl:variable name="outputDate">
    <xsl:call-template name="OutputDateIsRequired"/>
  </xsl:variable>

  <xsl:if test="$outputDate = 'true'">
    <xsl:call-template name="OutputDateTable"/>
  </xsl:if>

  <xsl:if test="(position() = 1) or not(preceding-sibling::*[1]/Stakeout/DTMDesign) or ($outputDate = 'true')">
    <!-- End any existing table -->
    <xsl:if test="(position() &gt; 1) and ($outputDate != 'true')">
      <xsl:call-template name="EndTable"/>
    </xsl:if>

    <xsl:call-template name="StartTable">
      <xsl:with-param name="caption" select="'DTM Stakeout'"/>
      <xsl:with-param name="includeBorders" select="'Yes'"/>
      <xsl:with-param name="tableWidth" select="80"/>
    </xsl:call-template>

    <!-- Output table column headings -->
    <tr>
      <th class="silverTitleLine" align="center" width="16%">Point Name</th>
      <th class="silverTitleLine" align="center" width="20%">Code</th>
      <th class="silverTitleLine" align="center" width="20%">DTM Name</th>
      <th class="silverTitleLine" align="center" width="11%">Design Z</th>
      <th class="silverTitleLine" align="center" width="11%">Staked Z</th>
      <th class="silverTitleLine" align="center" width="11%">Vert Offset</th>
      <th class="silverTitleLine" align="center" width="11%">Cut/Fill</th>
    </tr>
  </xsl:if>

  <!-- Output the DTM stake details -->
  <tr>
    <td align="left"><xsl:value-of select="Name"/></td>
    <td align="left"><xsl:value-of select="Code"/></td>
    <td align="left"><xsl:value-of select="Stakeout/DTMDesign/Name"/></td>
    <td align="right">
      <xsl:choose>
        <xsl:when test="$schemaVersion &gt;= 5.2">
          <xsl:value-of select="format-number((ComputedGrid/Elevation + Stakeout/DTMDeltas/DeltaElevation) * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="format-number((ComputedGrid/Elevation - Stakeout/DTMDeltas/DeltaElevation) * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number(ComputedGrid/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/DTMDesign/VerticalOffset * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right">
      <xsl:choose>
        <xsl:when test="$schemaVersion &gt;= 5.2">
          <xsl:value-of select="format-number(Stakeout/DTMDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="format-number(Stakeout/DTMDeltas/DeltaElevation * -1 * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
  </tr>

</xsl:template>


<!-- **************************************************************** -->
<!-- ************* Road Stakeout Deltas Details Output ************** -->
<!-- **************************************************************** -->
<xsl:template name="RoadStakeoutDeltas">

  <xsl:variable name="outputDate">
    <xsl:call-template name="OutputDateIsRequired"/>
  </xsl:variable>

  <xsl:if test="$outputDate = 'true'">
    <xsl:call-template name="OutputDateTable"/>
  </xsl:if>

  <xsl:if test="(position() = 1) or not(preceding-sibling::*[1]/Stakeout/RoadDesign) or ($outputDate = 'true') or
                (preceding-sibling::*[1]/Stakeout/RoadDesign and (preceding-sibling::*[1]/Stakeout/RoadDesign/Name != Stakeout/RoadDesign/Name))">
    <!-- End any existing table -->
    <xsl:if test="(position() &gt; 1) and ($outputDate != 'true')">
      <xsl:call-template name="EndTable"/>
    </xsl:if>

    <xsl:call-template name="StartTable">
      <xsl:with-param name="caption" select="concat('Road Stakeout: ', Stakeout/RoadDesign/Name)"/>
      <xsl:with-param name="includeBorders" select="'Yes'"/>
      <xsl:with-param name="tableWidth" select="100"/>
    </xsl:call-template>
    <!-- Output table column headings -->
    <xsl:choose>
      <xsl:when test="$includeCatchVertDists = 'Yes'">
        <tr>
          <th class="silverTitleLine" align="center" width="9%">Point Name</th>
          <th class="silverTitleLine" align="center" width="13%">Code</th>
          <th class="silverTitleLine" align="center" width="9%">
            <xsl:choose>
              <xsl:when test="$useChainageTerminology = 'true'">Chainage</xsl:when>
              <xsl:otherwise>Station</xsl:otherwise>
            </xsl:choose>
          </th>
          <th class="silverTitleLine" align="center" width="8%">Offset</th>
          <th class="silverTitleLine" align="center" width="9%">Const O/S (Hz/Vt)</th>
          <th class="silverTitleLine" align="center" width="8%">Design Z</th>
          <th class="silverTitleLine" align="center" width="8%">Staked Z</th>
          <th class="silverTitleLine" align="center" width="8%">Cut/Fill</th>
          <th class="silverTitleLine" align="center" width="7%">V. Dist to hinge</th>
          <th class="silverTitleLine" align="center" width="7%">V. Dist to CL</th>
          <th class="silverTitleLine" align="center" width="7%">
            <xsl:choose>
              <xsl:when test="$useChainageTerminology = 'true'">Δ Chainage</xsl:when>
              <xsl:otherwise>Δ Station</xsl:otherwise>
            </xsl:choose>
          </th>
          <th class="silverTitleLine" align="center" width="7%">Δ Offset</th>
        </tr>
      </xsl:when>
      <xsl:otherwise>
        <tr>
          <th class="silverTitleLine" align="center" width="10%">Point Name</th>
          <th class="silverTitleLine" align="center" width="15%">Code</th>
          <th class="silverTitleLine" align="center" width="11%">
            <xsl:choose>
              <xsl:when test="$useChainageTerminology = 'true'">Chainage</xsl:when>
              <xsl:otherwise>Station</xsl:otherwise>
            </xsl:choose>
          </th>
          <th class="silverTitleLine" align="center" width="10%">Offset</th>
          <th class="silverTitleLine" align="center" width="10%">Const O/S (Hz/Vt)</th>
          <th class="silverTitleLine" align="center" width="10%">Design Z</th>
          <th class="silverTitleLine" align="center" width="10%">Staked Z</th>
          <th class="silverTitleLine" align="center" width="8%">Cut/Fill</th>
          <th class="silverTitleLine" align="center" width="8%">
            <xsl:choose>
              <xsl:when test="$useChainageTerminology = 'true'">Δ Chainage</xsl:when>
              <xsl:otherwise>Δ Station</xsl:otherwise>
            </xsl:choose>
          </th>
          <th class="silverTitleLine" align="center" width="8%">Δ Offset</th>
        </tr>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:if>


  <!-- Output the road stake details -->
  <xsl:variable name="StnValue">
    <xsl:choose>
      <xsl:when test="Stakeout/RoadDesign/EquatedStation">
        <xsl:value-of select="Stakeout/RoadDesign/EquatedStation/Station"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="Stakeout/RoadDesign/Station"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="StnZone">
    <xsl:choose>
      <xsl:when test="Stakeout/RoadDesign/EquatedStation">
        <xsl:value-of select="Stakeout/RoadDesign/EquatedStation/Zone"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="''"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="stnVal">
    <xsl:call-template name="FormatStationVal">
      <xsl:with-param name="stationVal" select="$StnValue"/>
      <xsl:with-param name="zoneVal" select="$StnZone"/>
      <xsl:with-param name="definedFmt" select="$stnFormatStyle"/>
    </xsl:call-template>
  </xsl:variable>

  <xsl:variable name="offsetVal">
    <xsl:choose>
      <xsl:when test="Stakeout/RoadDesign/Offset != ''">
        <xsl:value-of select="format-number(Stakeout/RoadDesign/Offset * $DistConvFactor, $DecPl3, 'Standard')"/>
      </xsl:when>
      <xsl:when test="Stakeout/CatchPoint/Offset and
                      (Stakeout/CatchPoint/Offset &gt; 0.0)">
        <xsl:value-of select="'R Catch'"/>
      </xsl:when>
      <xsl:when test="Stakeout/CatchPoint/Offset and
                      (Stakeout/CatchPoint/Offset &lt; 0.0)">
        <xsl:value-of select="'L Catch'"/>
      </xsl:when>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="code">
    <xsl:choose>
      <xsl:when test="Code != ''">
        <xsl:value-of select="Code"/>
      </xsl:when>
      <xsl:when test="Stakeout/RoadDesign/Code != ''">
        <xsl:value-of select="Stakeout/RoadDesign/Code"/>
      </xsl:when>
      <xsl:when test="Stakeout/RoadDesign/Name != ''">
        <xsl:value-of select="Stakeout/RoadDesign/Name"/>
      </xsl:when>
      <xsl:otherwise>&#160;</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="asStakedElev">
    <xsl:choose>
      <xsl:when test="ComputedGrid">
        <xsl:value-of select="ComputedGrid/Elevation"/>
      </xsl:when>
      <xsl:otherwise> <!-- Precise elevation (integrated surveying) points have the combined position stored as a Grid element -->
        <xsl:value-of select="Grid/Elevation"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <tr>
    <td align="left"><xsl:value-of select="Name"/></td>
    <td align="left"><xsl:value-of select="$code"/></td>
    <td align="right"><xsl:value-of select="$stnVal"/></td>
    <td align="right"><xsl:value-of select="$offsetVal"/></td>
    <td align="right">
      <xsl:choose>
        <xsl:when test="string(number(Stakeout/RoadDesign/HorizontalConstructionOffset)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/RoadDesign/HorizontalConstructionOffset * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>0.000</xsl:otherwise>
      </xsl:choose>
      <xsl:text>/</xsl:text>
      <xsl:choose>
        <xsl:when test="string(number(Stakeout/RoadDesign/VerticalConstructionOffset)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/RoadDesign/VerticalConstructionOffset * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>0.000</xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right">
      <xsl:choose>
        <xsl:when test="string(number(Stakeout/RoadDesign/Elevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/RoadDesign/Elevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="deltaElev">
            <xsl:choose>
              <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
                <xsl:value-of select="Stakeout/GridDeltas/DeltaElevation"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="Stakeout/LinearDeltas/DeltaElevation"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:value-of select="format-number(($asStakedElev + $deltaElev) * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <td align="right"><xsl:value-of select="format-number($asStakedElev * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right">
      <xsl:choose>   <!-- Use the DeltaElevation from the GridDeltas element if possible -->
        <xsl:when test="string(number(Stakeout/GridDeltas/DeltaElevation)) != 'NaN'">
          <xsl:value-of select="format-number(Stakeout/GridDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaElevation * $DistConvFactor, $DecPl3, 'Standard')"/>
        </xsl:otherwise>
      </xsl:choose>
    </td>
    <xsl:if test="$includeCatchVertDists = 'Yes'">
      <xsl:choose>
        <xsl:when test="Stakeout/CatchPoint">
          <td align="right"><xsl:value-of select="format-number(Stakeout/CatchPoint/VerticalDistanceToHingePoint * $DistConvFactor, $DecPl3, 'Standard')"/></td>
          <td align="right"><xsl:value-of select="format-number((Stakeout/CrossSectionReport/CenterPoint/ComputedGrid/Elevation - Stakeout/CatchPoint/Elevation) * $DistConvFactor, $DecPl3, 'Standard')"/></td>
        </xsl:when>
        <xsl:otherwise>
          <td>&#160;</td>
          <td>&#160;</td>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
    <td align="right"><xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaStation * $DistConvFactor, $DecPl3, 'Standard')"/></td>
    <td align="right"><xsl:value-of select="format-number(Stakeout/LinearDeltas/DeltaOffset * $DistConvFactor, $DecPl3, 'Standard')"/></td>
  </tr>
</xsl:template>


<!-- **************************************************************** -->
<!-- ***************** Return Formatted Date String ***************** -->
<!-- **************************************************************** -->
<xsl:template name="FormattedDate">
  <xsl:param name="timeStamp"/>
  
  <xsl:variable name="date" select="substring($timeStamp, 9, 2)"/>
  
  <xsl:variable name="month">
    <xsl:variable name="monthNbr" select="substring($timeStamp, 6, 2)"/>
    <xsl:choose>
      <xsl:when test="number($monthNbr) = 1">Jan</xsl:when>
      <xsl:when test="number($monthNbr) = 2">Feb</xsl:when>
      <xsl:when test="number($monthNbr) = 3">Mar</xsl:when>
      <xsl:when test="number($monthNbr) = 4">Apr</xsl:when>
      <xsl:when test="number($monthNbr) = 5">May</xsl:when>
      <xsl:when test="number($monthNbr) = 6">Jun</xsl:when>
      <xsl:when test="number($monthNbr) = 7">Jul</xsl:when>
      <xsl:when test="number($monthNbr) = 8">Aug</xsl:when>
      <xsl:when test="number($monthNbr) = 9">Sep</xsl:when>
      <xsl:when test="number($monthNbr) = 10">Oct</xsl:when>
      <xsl:when test="number($monthNbr) = 11">Nov</xsl:when>
      <xsl:when test="number($monthNbr) = 12">Dec</xsl:when>
    </xsl:choose>
  </xsl:variable>
  
  <xsl:value-of select="concat($date, ' ', $month, ' ', substring($timeStamp, 1, 4))"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************** Check if a date output is required ************** -->
<!-- **************************************************************** -->
<xsl:template name="OutputDateIsRequired">

  <xsl:variable name="thisDate" select="substring-before(@TimeStamp, 'T')"/>
  <xsl:variable name="prevDate" select="substring-before(preceding-sibling::*[1]/@TimeStamp, 'T')"/>

  <xsl:choose>
    <xsl:when test="(position() = 1) or ($outputOrder != 'As observed')">false</xsl:when>
    <xsl:when test="$thisDate != $prevDate">true</xsl:when>
    <xsl:otherwise>false</xsl:otherwise>
  </xsl:choose>

</xsl:template>


<!-- **************************************************************** -->
<!-- ******** Build up a node set of the valid output dates ********* -->
<!-- **************************************************************** -->
<xsl:template name="InDateRange">
  <xsl:param name="date"/>

  <xsl:choose>
    <xsl:when test="($startJulianDay = '') or ($endJulianDay = '')">true</xsl:when>
    <xsl:otherwise>
      <xsl:variable name="thisJulianDay">
        <xsl:call-template name="TimeStampToJulianDay">
          <xsl:with-param name="timeStamp" select="concat($date, 'T00:00:00')"/>
        </xsl:call-template>
      </xsl:variable>
      
      <xsl:choose>
        <xsl:when test="($thisJulianDay &gt;= $startJulianDay) and ($thisJulianDay &lt;= $endJulianDay)">true</xsl:when>
        <xsl:otherwise>false</xsl:otherwise>
      </xsl:choose>
    </xsl:otherwise>
  </xsl:choose>

</xsl:template>


<!-- **************************************************************** -->
<!-- ***************** Output a table with the date ***************** -->
<!-- **************************************************************** -->
<xsl:template name="OutputDateTable">
  <xsl:param name="skipEndTable" select="'false'"/>
  
  <!-- End any existing table -->
  <xsl:if test="$skipEndTable = 'false'">
    <xsl:call-template name="EndTable"/>
  </xsl:if>

  <br/>
  <xsl:call-template name="StartTable"/>
    <tr>
      <th class="blackTitleLine" align="left" width="100%">
        <xsl:call-template name="FormattedDate">
          <xsl:with-param name="timeStamp" select="@TimeStamp"/>
        </xsl:call-template>
      </th>
    </tr>
  <xsl:call-template name="EndTable"/>
  <br/>

</xsl:template>


<!-- **************************************************************** -->
<!-- ************************* Start Table ************************** -->
<!-- **************************************************************** -->
<xsl:template name="StartTable">
  <xsl:param name="includeBorders" select="'Yes'"/>
  <xsl:param name="tableWidth" select="100"/>
  <xsl:param name="caption"/>

  <xsl:choose>
    <xsl:when test="$includeBorders = 'Yes'">
      <xsl:value-of disable-output-escaping="yes" select="concat('&lt;table border=1 width=', $tableWidth, '% cellpadding=4 cellspacing=0 bordercolor=silver bordercolordark=silver rules=all&gt;')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of disable-output-escaping="yes" select="concat('&lt;table border=0 width=', $tableWidth, '% cellpadding=4 cellspacing=0 bordercolor=silver bordercolordark=silver rules=cols&gt;')"/>
    </xsl:otherwise>
  </xsl:choose>

  <xsl:if test="$caption != ''">
    <caption align="top"><p align="left"><b><xsl:value-of select="$caption"/></b></p></caption>
  </xsl:if>
</xsl:template>


<!-- **************************************************************** -->
<!-- ************************** End Table *************************** -->
<!-- **************************************************************** -->
<xsl:template name="EndTable">
  <xsl:value-of disable-output-escaping="yes" select="'&lt;/table&gt;'"/>
</xsl:template>


<!-- **************************************************************** -->
<!-- ****************** Separating Line Output ********************** -->
<!-- **************************************************************** -->
<xsl:template name="SeparatingLine">
  <hr/>
</xsl:template>


<!-- **************************************************************** -->
<!-- *************** Return Formatted Station Value ***************** -->
<!-- **************************************************************** -->
<xsl:template name="FormatStationVal">
  <xsl:param name="stationVal"/>
  <xsl:param name="zoneVal" select="''"/>
  <xsl:param name="definedFmt" select="''"/>
  <xsl:param name="stationIndexIncrement" select="''"/>
  <xsl:param name="decPlDefnStr" select="''"/>

  <xsl:variable name="decPl">
    <xsl:choose>
      <xsl:when test="$decPlDefnStr != ''">
        <xsl:value-of select="$decPlDefnStr"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$DecPl3"/>  <!-- Default to 3 decimal places -->
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:choose>
    <xsl:when test="string(number($stationVal)) = 'NaN'">
      <xsl:value-of select="format-number($stationVal, $decPl, 'Standard')"/>  <!-- Return appropriate formatted null value -->
    </xsl:when>
    <xsl:otherwise>
      <xsl:variable name="formatStyle">
        <xsl:choose>
          <xsl:when test="$definedFmt = ''">
            <xsl:value-of select="/JOBFile/Environment/DisplaySettings/StationingFormat"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$definedFmt"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:variable name="stnIndexIncrement">
        <xsl:choose>
          <xsl:when test="string(number($stationIndexIncrement)) = 'NaN'">
            <xsl:value-of select="/JOBFile/Environment/DisplaySettings/StationIndexIncrement"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="$stationIndexIncrement"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xsl:variable name="stnVal" select="format-number($stationVal * $DistConvFactor, $decPl, 'Standard')"/>
      <xsl:variable name="signChar">
        <xsl:if test="$stnVal &lt; 0.0">-</xsl:if>
      </xsl:variable>

      <xsl:variable name="absStnVal" select="concat(substring('-',2 - ($stnVal &lt; 0)), '1') * $stnVal"/>

      <xsl:variable name="intPart" select="substring-before(format-number($absStnVal, $DecPl3, 'Standard'), '.')"/>
      <xsl:variable name="decPart" select="substring-after($stnVal, '.')"/>

      <xsl:if test="$formatStyle = '1000.0'">
        <xsl:value-of select="$stnVal"/>
      </xsl:if>

      <xsl:if test="$formatStyle = '10+00.0'">
        <xsl:choose>
          <xsl:when test="string-length($intPart) &gt; 2">
            <xsl:value-of select="concat($signChar, substring($intPart, 1, string-length($intPart) - 2),
                                         '+', substring($intPart, string-length($intPart) - 1, 2))"/>
            <xsl:if test="$decPart != ''">
              <xsl:text>.</xsl:text>
              <xsl:value-of select="$decPart"/>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat($signChar, '0+', substring('00', 1, 2 - string-length($intPart)), $intPart)"/>
            <xsl:if test="$decPart != ''">
              <xsl:text>.</xsl:text>
              <xsl:value-of select="$decPart"/>
            </xsl:if>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>

      <xsl:if test="$formatStyle = '1+000.0'">
        <xsl:choose>
          <xsl:when test="string-length($intPart) &gt; 3">
            <xsl:value-of select="concat($signChar, substring($intPart, 1, string-length($intPart) - 3),
                                         '+', substring($intPart, string-length($intPart) - 2, 3))"/>
            <xsl:if test="$decPart != ''">
              <xsl:text>.</xsl:text>
              <xsl:value-of select="$decPart"/>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat($signChar, '0+', substring('000', 1, 3 - string-length($intPart)), $intPart)"/>
            <xsl:if test="$decPart != ''">
              <xsl:text>.</xsl:text>
              <xsl:value-of select="$decPart"/>
            </xsl:if>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>

      <xsl:if test="$formatStyle = 'StationIndex'">
        <xsl:variable name="intIncrement" select="format-number($stnIndexIncrement * $DistConvFactor, $DecPl0, 'Standard')"/>

        <xsl:variable name="afterPlusDigits" select="string-length($intIncrement)"/>
        <xsl:variable name="afterPlusZeros" select="substring('000000000000', 1, $afterPlusDigits)"/>
        <xsl:variable name="afterPlusFmt" select="concat($afterPlusZeros, '.', substring-after($decPl, '.'))"/>

        <xsl:variable name="beforePlus" select="floor($absStnVal div ($stnIndexIncrement * $DistConvFactor))"/>
        <xsl:variable name="afterPlus" select="$absStnVal - $beforePlus * ($stnIndexIncrement * $DistConvFactor)"/>
        <xsl:value-of select="concat($signChar, format-number($beforePlus, '#0'), '+', format-number($afterPlus, $afterPlusFmt, 'Standard'))"/>
      </xsl:if>

      <xsl:if test="$zoneVal != ''">
        <xsl:value-of select="':'"/>
        <xsl:value-of select="format-number($zoneVal,'0')"/>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>


<!-- **************************************************************** -->
<!-- ********* Return the Julian Day for a given TimeStamp ********** -->
<!-- **************************************************************** -->
<xsl:template name="TimeStampToJulianDay">
  <!-- The formula used in this function is valid for the years 1901 - 2099 -->
  <xsl:param name="timeStamp"/>

  <xsl:variable name="Y" select="substring($timeStamp, 1, 4)"/>
  <xsl:variable name="M" select="substring($timeStamp, 6, 2)"/>
  <xsl:variable name="D" select="substring($timeStamp, 9, 2)"/>
  <xsl:variable name="h" select="substring($timeStamp, 12, 2)"/>
  <xsl:variable name="m" select="substring($timeStamp, 15, 2)"/>
  <xsl:variable name="s" select="substring($timeStamp, 18, 2)"/>

  <xsl:value-of select="format-number(367 * $Y - floor(7 * ($Y + floor(($M + 9) div 12)) div 4) +
                                      floor(275 * $M div 9) + $D + 1721013.5 +
                                      ($h + $m div 60 + $s div 3600) div 24, '0.000000000')"/>
</xsl:template>


</xsl:stylesheet>
